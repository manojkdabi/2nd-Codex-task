/***************************************************************
 * Insoil Live Observation Tool - Backend (Code.gs)
 * v5.85 - FINAL FIX: Unlimited Data + Service Logic
 ***************************************************************/

// InsoilTool version: 2026-01-16a (backend)

/* =====================================================================
 * MODULE LIST (backend sections)
 * 0) App metadata & HTML bootstrap (doGet/include/version/build)
 * 1) Config & initial data loading (getInitialData + helpers)
 * 2) Sheet object readers & normalization helpers
 * 3) QC/Prod master tables (read/save + master lists)
 * 4) RGB/QC operational data + sync/transfer logic
 * 5) Service, admin, and utility functions
 * 6) Inventory Manager (sheets + data flow)
 * ===================================================================== */

// =============================
// MODULE 0: BOOTSTRAP & VERSION
// =============================
// Add version constant at top of Code.gs
const APP_VERSION = 'v6.00';
const BUILD_TIMESTAMP = new Date().toISOString().slice(0, 16).replace('T', ' ');

function doGet(e) {
  return HtmlService.createHtmlOutputFromFile('InsoilTool')
    .setTitle(`Insoil Tool ${APP_VERSION} (${BUILD_TIMESTAMP})`)
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}


function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

function getAppVersion() {
  return {
    version: APP_VERSION,
    buildTime: BUILD_TIMESTAMP,
    deployed: new Date().toISOString()
  };
}

const BUILD_TAG = 'BUILD-2026-01-12T13:45-IST';

function getBuildInfo() {
  return {
    build: 'BUILD-2026-01-12T13:45-IST',
    now: new Date().toISOString()
  };
}




/**
 * =============================
 * MODULE 1: CONFIG & DATA LOAD
 * =============================
 */

function getDataByHeaders(ss, sheetName, headers) {
  const sh = ss.getSheetByName(sheetName);
  if (!sh) return [];

  const data = sh.getDataRange().getValues();
  if (data.length < 2) return [];

  const headerRow = data[0].map(h => String(h).trim());
  const idxMap = headers.map(h => headerRow.indexOf(h));

  // If any header is missing, return empty to prevent offset errors
  if (idxMap.some(i => i === -1)) return [];

  const out = [];
  for (let r = 1; r < data.length; r++) {
    const row = data[r];
    out.push(idxMap.map(c => {
      const v = row[c];
      // Inline Sanitization: Remove Excel Errors (#N/A) and Infinite numbers
      if (v instanceof Error) return "";
      if (typeof v === 'number' && !isFinite(v)) return "";
      return (v === null || v === undefined) ? "" : v;
    }));
  }
  return out;
}
/**
 * CORRECTED getInitialData
 * - Removes duplicate definitions
 * - Calls the correct helper: getDataByHeaders (plural, no underscore)
 */
// ============================================================================
// INITIAL LOAD (Frontend calls google.script.run.getInitialData())
// Must ALWAYS return an object (never null)
// ============================================================================

function getInitialData() {
  const cache = CacheService.getScriptCache();
  const cacheKey = 'initialData:v1';
  const cached = cache.get(cacheKey);
  if (cached) {
    try {
      return JSON.parse(cached);
    } catch (err) {
      // Ignore cache parse errors and fall back to live read.
    }
  }
  const traceId = 'SRV-' + new Date().toISOString() + '-' + Utilities.getUuid();
  const t0 = Date.now();

  // IMPORTANT: Never return undefined. Return OK/ERROR envelope always.
  const out = {
    __traceId: traceId,
    __status: 'OK',
    __missingSheets: [],
    __info: { ms: 0, counts: {} },

    // payload keys used by frontend
    criteria: [],
    stv: [],
    qcCriteria: [],
    blanks: [],
    registry: [],
    serviceConfig: [],
    recipeConfig: {}
  };

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    if (!ss) {
      // If this is a standalone script (not bound), this can be null.
      // Return ERROR envelope (so frontend shows message), do not return undefined.
      out.__status = 'ERROR';
      out.__error = 'No active spreadsheet. If this is a standalone Apps Script, bind it to a Sheet or open by ID.';
      out.__info.ms = Date.now() - t0;
      console.log('[getInitialData] ERROR no active spreadsheet traceId=' + traceId);
      return out;
    }

    // Ensure Crop columns exist/default before initial load (RGB_Data + QC_Data + SoilTest_Results)
    const rgbSheet = ss.getSheetByName('RGB_Data');
    if (rgbSheet) {
      const rgbHeaderRow = findHeaderRowIndexByKeys_(rgbSheet, ['deviceid', 'testid']);
      if (rgbHeaderRow > 0) {
        ensureColumnWithDefault_(rgbSheet, rgbHeaderRow, 'Crop', 'Wheat');
        moveColumnAfter_(rgbSheet, rgbHeaderRow, 'Crop', 'Farm_ID');
      }
    }
    const qcSheet = ss.getSheetByName('QC_Data');
    if (qcSheet) {
      const qcHeaderRow = findHeaderRowIndexByKeys_(qcSheet, ['deviceid', 'testid']);
      if (qcHeaderRow > 0) {
        ensureColumnWithDefault_(qcSheet, qcHeaderRow, 'Crop', 'Wheat');
        moveColumnAfter_(qcSheet, qcHeaderRow, 'Crop', 'Farm_ID');
      }
    }
    ensureSoilTestResultsSheet_();
    const soilSheet = ss.getSheetByName('SoilTest_Results');
    if (soilSheet) {
      ensureColumnWithDefault_(soilSheet, 1, 'Crop', 'Wheat');
      moveColumnAfter_(soilSheet, 1, 'Crop', 'Farm_ID');
    }

    // Inventory Manager sheets
    ensureInventorySheets_(ss, out.__missingSheets);

    out.criteria = readSheetAsObjects(ss, 'Criteria', out.__missingSheets);
    out.stv = readSheetAsObjects(ss, 'STV', out.__missingSheets);
    out.qcCriteria = readSheetAsObjects(ss, 'QC_Criteria', out.__missingSheets);
    out.blanks = readSheetAsObjects(ss, 'Blanks', out.__missingSheets);
    if (!out.blanks.length) {
      out.blanks = readSheetAsObjects(ss, 'Blank_Values', out.__missingSheets);
    }
    if (!out.blanks.length) {
      out.blanks = readSheetAsObjects(ss, 'Blank Values', out.__missingSheets);
    }
    if (!out.blanks.length) {
      out.blanks = readSheetAsObjects(ss, 'BlankValues', out.__missingSheets);
    }
    out.registry = readSheetAsObjects(ss, 'Device_Registry', out.__missingSheets);
    out.serviceConfig = readSheetAsObjects(ss, 'Service_Config', out.__missingSheets);
    out.stvInfo = getLatestStvInfo_(ss);

    // Optional key-value style sheet (safe if missing)
    out.recipeConfig = readKeyValueSheet(ss, 'Recipe_Config', out.__missingSheets);

    // counts
    out.__info.counts = {
      criteria: out.criteria.length,
      stv: out.stv.length,
      qcCriteria: out.qcCriteria.length,
      blanks: out.blanks.length,
      registry: out.registry.length,
      serviceConfig: out.serviceConfig.length
    };

    out.__info.ms = Date.now() - t0;
    console.log('[getInitialData] OK traceId=' + traceId + ' ms=' + out.__info.ms +
      ' missing=' + JSON.stringify(out.__missingSheets) +
      ' counts=' + JSON.stringify(out.__info.counts));
    cache.put(cacheKey, JSON.stringify(out), 60);
    return out;

  } catch (err) {
    out.__status = 'ERROR';
    out.__error = (err && err.message) ? err.message : String(err);
    out.__stack = (err && err.stack) ? String(err.stack) : '';
    out.__info.ms = Date.now() - t0;

    console.log('[getInitialData] ERROR traceId=' + traceId + ' ms=' + out.__info.ms + ' err=' + out.__error);
    return out; // never undefined
  }
}

// =============================
// DASHBOARD SUMMARY
// =============================
function getDashboardData() {
  const out = {
    status: 'OK',
    generatedAt: new Date().toISOString(),
    metrics: {
      devices: 0,
      rgbRecords: 0,
      qaqcRecords: 0,
      soilResults: 0,
      uniqueFarms: 0
    },
    sources: [],
    missingSheets: []
  };

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) {
    out.status = 'ERROR';
    out.error = 'No active spreadsheet found.';
    return out;
  }

  const metricSheets = [
    { key: 'devices', name: 'Device_Registry' },
    { key: 'rgbRecords', name: 'RGB_Data' },
    { key: 'qaqcRecords', name: 'QC_Data' },
    { key: 'soilResults', name: 'SoilTest_Results' }
  ];

  metricSheets.forEach(entry => {
    const count = getSheetRowCount_(ss, entry.name, out.missingSheets);
    if (typeof count === 'number') {
      out.metrics[entry.key] = count;
      out.sources.push({ name: entry.name, rows: count });
    }
  });

  out.metrics.uniqueFarms = getUniqueFarmCount_(ss, out.missingSheets);

  return out;
}

function getSheetRowCount_(ss, sheetName, missingSheetsArr) {
  const sh = ss.getSheetByName(sheetName);
  if (!sh) {
    addMissingSheet_(missingSheetsArr, sheetName);
    return 0;
  }
  const lastRow = sh.getLastRow();
  return Math.max(0, lastRow - 1);
}

function getUniqueFarmCount_(ss, missingSheetsArr) {
  const farmSheets = ['SoilTest_Results', 'RGB_Data', 'QC_Data'];
  for (let i = 0; i < farmSheets.length; i++) {
    const sh = ss.getSheetByName(farmSheets[i]);
    if (!sh) {
      addMissingSheet_(missingSheetsArr, farmSheets[i]);
      continue;
    }
    const headerRow = Math.max(1, findHeaderRowIndexByKeys_(sh, ['farm']));
    const count = countUniqueValuesInSheet_(sh, headerRow, ['farm_id', 'farm id', 'farmid']);
    if (count !== null) return count;
  }
  return 0;
}

function countUniqueValuesInSheet_(sheet, headerRow, headerCandidates) {
  if (!sheet) return null;
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow <= headerRow || lastCol < 1) return 0;

  const headers = sheet.getRange(headerRow, 1, 1, lastCol).getDisplayValues()[0];
  const targetCol = findHeaderIndex_(headers, headerCandidates);
  if (targetCol < 0) return null;

  const values = sheet.getRange(headerRow + 1, targetCol + 1, lastRow - headerRow, 1).getDisplayValues();
  const unique = new Set();
  values.forEach(row => {
    const v = String(row[0] || '').trim();
    if (v) unique.add(v);
  });
  return unique.size;
}

function findHeaderIndex_(headers, candidates) {
  const normalizedCandidates = (candidates || []).map(c => normalizeHeader_(c));
  for (let i = 0; i < headers.length; i++) {
    const normalized = normalizeHeader_(headers[i]);
    if (!normalized) continue;
    if (normalizedCandidates.includes(normalized)) return i;
  }
  return -1;
}

function normalizeHeader_(value) {
  return String(value || '').trim().toLowerCase().replace(/[\s_.-]/g, '');
}

function addMissingSheet_(missingSheetsArr, sheetName) {
  if (!Array.isArray(missingSheetsArr)) return;
  if (!sheetName) return;
  if (!missingSheetsArr.includes(sheetName)) missingSheetsArr.push(sheetName);
}

// =============================
// STV DIRECT (CSV IMPORT + READ)
// =============================
const STV_DIRECT_SHEET = 'STV_Direct';
const STV_DIRECT_HEADERS = [
  'Test_ID',
  'Device_ID',
  'ClientID',
  'Farm_ID',
  'Crop',
  'Date',
  'pH',
  'EC',
  'OC',
  'Avail_N',
  'Avail_P',
  'Avail_K',
  'Avail_S',
  'Zn',
  'Fe',
  'Mn',
  'Cu',
  'B'
];

function getSTVDirectData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) {
    return { status: 'ERROR', error: 'No active spreadsheet found.' };
  }
  ensureSTVDirectSheet_(ss);
  const rows = readSheetAsObjects(ss, STV_DIRECT_SHEET);
  return { status: 'OK', rows: rows };
}

function srvr_ImportSTVDirectCSV(payload) {
  const csvText = payload && payload.csvText ? String(payload.csvText) : '';
  if (!csvText.trim()) {
    return { addedCount: 0, errorCount: 1, errors: ['CSV is empty.'] };
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) {
    return { addedCount: 0, errorCount: 1, errors: ['No active spreadsheet found.'] };
  }

  const sheet = ensureSTVDirectSheet_(ss);
  const parsed = Utilities.parseCsv(csvText);
  if (!parsed.length) {
    return { addedCount: 0, errorCount: 1, errors: ['CSV could not be parsed.'] };
  }

  const headerRow = parsed[0] || [];
  const headerMap = buildHeaderIndexMap_(headerRow);
  const missing = STV_DIRECT_HEADERS.filter(h => headerMap[normalizeHeader_(h)] == null);
  if (missing.length) {
    return { addedCount: 0, errorCount: missing.length, errors: [`Missing headers: ${missing.join(', ')}`] };
  }

  const rows = [];
  for (let i = 1; i < parsed.length; i++) {
    const row = parsed[i];
    if (!row || row.join('').trim() === '') continue;
    const out = STV_DIRECT_HEADERS.map(h => {
      const idx = headerMap[normalizeHeader_(h)];
      return idx != null ? row[idx] : '';
    });
    rows.push(out);
  }

  if (!rows.length) {
    return { addedCount: 0, errorCount: 0 };
  }

  sheet.getRange(sheet.getLastRow() + 1, 1, rows.length, STV_DIRECT_HEADERS.length).setValues(rows);
  return { addedCount: rows.length, errorCount: 0 };
}

function ensureSTVDirectSheet_(ss) {
  let sheet = ss.getSheetByName(STV_DIRECT_SHEET);
  if (!sheet) {
    sheet = ss.insertSheet(STV_DIRECT_SHEET);
  }
  const headerRange = sheet.getRange(1, 1, 1, STV_DIRECT_HEADERS.length);
  const existing = headerRange.getValues()[0];
  const hasHeader = existing.some(cell => String(cell || '').trim() !== '');
  if (!hasHeader) {
    headerRange.setValues([STV_DIRECT_HEADERS]);
  }
  return sheet;
}

function buildHeaderIndexMap_(headerRow) {
  const map = {};
  headerRow.forEach((h, idx) => {
    const key = normalizeHeader_(h);
    if (key && map[key] == null) map[key] = idx;
  });
  return map;
}

// =============================
// MODULE 2: SHEET READ HELPERS
// =============================
function readSheetAsObjects(ss, sheetName, missingSheetsArr) {
  const sh = ss.getSheetByName(sheetName);
  if (!sh) {
    if (Array.isArray(missingSheetsArr)) missingSheetsArr.push(sheetName);
    return [];
  }

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2 || lastCol < 1) return [];

  const headers = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(h => String(h || '').trim());
  const data = sh.getRange(2, 1, lastRow - 1, lastCol).getValues();

  const rows = [];
  for (let r = 0; r < data.length; r++) {
    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      const key = headers[c];
      if (!key) continue;

      let v = data[r][c];

      // Make Dates safely serializable (optional but helps prevent odd client-side behavior)
      if (v instanceof Date) v = v.toISOString();

      obj[key] = v;
    }
    rows.push(obj);
  }
  return rows;
}

function readKeyValueSheet(ss, sheetName, missingSheetsArr) {
  const sh = ss.getSheetByName(sheetName);
  if (!sh) {
    if (Array.isArray(missingSheetsArr)) missingSheetsArr.push(sheetName);
    return {};
  }

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2 || lastCol < 2) return {};

  // Expect columns: Key | Value (anything beyond is ignored)
  const data = sh.getRange(2, 1, lastRow - 1, 2).getValues();
  const out = {};
  data.forEach(row => {
    const k = String(row[0] || '').trim();
    if (!k) return;
    let v = row[1];
    if (v instanceof Date) v = v.toISOString();
    out[k] = v;
  });
  return out;
}

function getLatestStvInfo_(ss) {
  const sh = ss.getSheetByName('STV_Update_Log');
  if (!sh) return null;

  const data = sh.getDataRange().getValues();
  if (data.length < 2) return null;

  const headers = data[0].map(h => String(h || '').trim());
  const idx = {};
  headers.forEach((h, i) => {
    idx[String(h || '').trim().toLowerCase()] = i;
  });

  const iRun = idx['stv_run_id'];
  const iSaved = idx['saved_at'];
  const iBy = idx['saved_by'];
  const iVer = idx['stv_version'];

  let best = null;
  for (let r = 1; r < data.length; r++) {
    const row = data[r];
    const ver = iVer != null ? row[iVer] : '';
    const saved = iSaved != null ? row[iSaved] : '';
    const d = _parseAnyDate_(saved) || _parseAnyDate_(ver);
    if (!d) continue;
    if (!best || d > best.date) {
      best = {
        date: d,
        runId: iRun != null ? String(row[iRun] || '').trim() : '',
        savedAt: iSaved != null ? String(row[iSaved] || '').trim() : '',
        savedBy: iBy != null ? String(row[iBy] || '').trim() : '',
        version: iVer != null ? String(row[iVer] || '').trim() : ''
      };
    }
  }

  if (!best) return null;
  return {
    runId: best.runId,
    savedAt: best.savedAt,
    savedBy: best.savedBy,
    version: best.version || (best.date ? best.date.toISOString() : '')
  };
}



// ------------------------ Helpers (no trailing "_" in names) ------------------------

function srvrGetSheet(ss, name) {
  return ss.getSheetByName(name);
}

function srvrGetValuesNoHeader(sh) {
  if (!sh) return [];
  const lr = sh.getLastRow();
  const lc = sh.getLastColumn();
  if (lr < 2 || lc < 1) return [];
  return sh.getRange(2, 1, lr - 1, lc).getValues();
}

function srvrGetHeaders(sh) {
  if (!sh) return [];
  const lc = sh.getLastColumn();
  if (lc < 1) return [];
  return sh.getRange(1, 1, 1, lc).getValues()[0].map(h => String(h || "").trim());
}

function srvrNum(v) {
  if (v === "" || v == null) return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function srvrLowerMap(headers) {
  const m = {};
  headers.forEach((h, i) => {
    const k = String(h || "").trim().toLowerCase();
    if (k) m[k] = i;
  });
  return m;
}

// ------------------------ Readers matching your frontend renderers ------------------------

function srvrReadCriteria(ss) {
  const sh = srvrGetSheet(ss, "Criteria");
  if (!sh) return [];
  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);
  const rows = srvrGetValuesNoHeader(sh);

  // Frontend renderCriteria expects objects: {s,p,m,l,rel,u,re,ac}
  return rows
    .filter(r => r.some(x => String(x || "").trim() !== ""))
    .map(r => ({
      s: String(r[col["spectro"]] || ""),
      p: String(r[col["parameter"]] || ""),
      m: String(r[col["metric"]] || ""),
      l: String(r[col["l.limit"]] || r[col["l.limit ".trim()]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || r[col["l.limit"]] || ""),
      rel: String(r[col["relation"]] || ""),
      u: String(r[col["u.limit"]] || ""),
      re: String(r[col["reason"]] || ""),
      ac: String(r[col["action"]] || "")
    }));
}

function srvrReadSTV(ss) {
  const sh = srvrGetSheet(ss, "STV");
  if (!sh) return [];
  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);
  const rows = srvrGetValuesNoHeader(sh);

  // Frontend renderSTV expects objects: {p,a,b,df1,df2,df3,df4}
  return rows
    .filter(r => r.some(x => String(x || "").trim() !== ""))
    .map(r => ({
      p: String(r[col["parameter"]] || ""),
      a: srvrNum(r[col["a"]]),
      b: srvrNum(r[col["b"]]),
      df1: srvrNum(r[col["df1"]]),
      df2: srvrNum(r[col["df2"]]),
      df3: srvrNum(r[col["df3"]]),
      df4: srvrNum(r[col["df4"]])
    }));
}

function srvrReadQCCriteria(ss) {
  const sh = srvrGetSheet(ss, "QC_Criteria");
  if (!sh) return [];
  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);
  const rows = srvrGetValuesNoHeader(sh);

  // Frontend renderQCCriteria expects objects: {batch,p,min,max,mean}
  // We try to map by common header names; if your headers differ, rename sheet headers to:
  // QC_Batch | Parameter | Min | Max | Mean
  return rows
    .filter(r => r.some(x => String(x || "").trim() !== ""))
    .map(r => ({
      batch: String(r[col["qc_batch"]] || r[col["qc batch"]] || r[col["batch"]] || "Default"),
      p: String(r[col["parameter"]] || r[col["param"]] || ""),
      min: srvrNum(r[col["min"]]),
      max: srvrNum(r[col["max"]]),
      mean: srvrNum(r[col["mean"]])
    }));
}

function srvrReadBlanks(ss) {
  const sh = srvrGetSheet(ss, "Blanks");
  if (!sh) return [];
  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);
  const rows = srvrGetValuesNoHeader(sh);

  // Frontend renderBlanks expects objects: {p,val}
  // Prefer headers: Parameter | Value
  return rows
    .filter(r => r.some(x => String(x || "").trim() !== ""))
    .map(r => ({
      p: String(r[col["parameter"]] || r[col["param"]] || ""),
      val: srvrNum(r[col["value"]] || r[col["val"]])
    }));
}

function srvrReadRegistryRows(ss) {
  const sh = srvrGetSheet(ss, "Device_Registry");
  if (!sh) return [];
  return srvrGetValuesNoHeader(sh); // frontend mapRegistryRow(row) expects raw rows
}

function srvrReadServiceConfig(ss) {
  const sh = srvrGetSheet(ss, "Service_Config");
  if (!sh) return []; // frontend already has a fallback mock in your rough file
  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);
  const rows = srvrGetValuesNoHeader(sh);

  // processServiceConfig expects items like:
  // { section, btn, sub, act, subActions }
  return rows
    .filter(r => r.some(x => String(x || "").trim() !== ""))
    .map(r => ({
      section: String(r[col["section"]] || ""),
      btn: String(r[col["btn"]] || r[col["button"]] || ""),
      sub: String(r[col["sub"]] || ""),
      act: String(r[col["act"]] || r[col["action"]] || ""),
      subActions: String(r[col["subactions"]] || r[col["sub_actions"]] || r[col["sub actions"]] || "")
    }));
}

function srvrReadRecipeConfig(ss) {
  // Supports either:
  // 1) Sheet "Recipe_Config" with JSON in A1
  // 2) Tabular rows which frontend can still interpret if you later code it
  const sh = srvrGetSheet(ss, "Recipe_Config");
  if (!sh) return null;

  const a1 = String(sh.getRange(1, 1).getValue() || "").trim();
  if (a1 && (a1[0] === "{" || a1[0] === "[")) {
    try {
      return JSON.parse(a1);
    } catch (e) {
      // If JSON is malformed, return null so frontend fallback can apply
      return null;
    }
  }

  // If not JSON, return raw rows (excluding header)
  return srvrGetValuesNoHeader(sh);
}


// =============================
// MODULE 4: OPERATIONAL DATA
// =============================
function getOperationalData() {
  const SAFE = { rgbData: [], qcData: [], __status: 'OK' };

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    if (!ss) throw new Error('No active spreadsheet bound to script');

    // RGB_Data is expected; QC_Data is optional (depending on your deployment state)
    const rgbSheet = ss.getSheetByName('RGB_Data');
    if (!rgbSheet) throw new Error('Missing required sheet: RGB_Data');

    const qcSheet = ss.getSheetByName('QC_Data'); // optional

    // UNLIMITED DATA LOAD (as you want)
    const rgbData = getRGBDataFormatted_(ss, 'RGB_Data', false) || [];
    let qcData = [];
    if (qcSheet) {
      qcData = getRGBDataFormatted_(ss, 'QC_Data', true) || [];
    } else {
      Logger.log('[WARN] QC_Data sheet not found; returning qcData=[]');
    }

    SAFE.rgbData = Array.isArray(rgbData) ? rgbData : [];
    SAFE.qcData = Array.isArray(qcData) ? qcData : [];

    Logger.log(`[getOperationalData] rgb=${SAFE.rgbData.length}, qc=${SAFE.qcData.length}`);
    return SAFE;

  } catch (e) {
    Logger.log('[getOperationalData FATAL] ' + e.message);
    return { rgbData: [], qcData: [], __status: 'ERROR', __error: e.message };
  }
}

/**
 * Return operational data limited to the last N days.
 * Used for fast initial load; full data can be warmed later.
 */
function getOperationalDataRecent(days) {
  const SAFE = { rgbData: [], qcData: [], __status: 'OK' };
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    if (!ss) throw new Error('No active spreadsheet bound to script');

    const nDays = Number(days) || 30;
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - nDays);

    const rgbData = getRGBDataFormatted_(ss, 'RGB_Data', false) || [];
    const qcSheet = ss.getSheetByName('QC_Data');
    const qcData = qcSheet ? (getRGBDataFormatted_(ss, 'QC_Data', true) || []) : [];

    const isRecent = (row) => {
      if (!row) return false;
      const v = row.Test_date ?? row.time ?? row.Date ?? row.datetime ?? '';
      const d = _parseAnyDate_(v);
      if (!d || isNaN(d.getTime())) return false;
      return d >= cutoff;
    };

    SAFE.rgbData = rgbData.filter(isRecent);
    SAFE.qcData = qcData.filter(isRecent);

    return SAFE;
  } catch (e) {
    Logger.log('[getOperationalDataRecent FATAL] ' + e.message);
    return { rgbData: [], qcData: [], __status: 'ERROR', __error: e.message };
  }
}



function syncMoveDataToQC(reqRows) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const shSrc = ss.getSheetByName("RGB_Data");
    if (!shSrc) return { ok: false, message: "RGB_Data sheet not found." };

    let shDst = ss.getSheetByName("QC_Data");
    if (!shDst) shDst = ss.insertSheet("QC_Data");

    const items = Array.isArray(reqRows) ? reqRows : JSON.parse(reqRows || "[]");
    if (!Array.isArray(items) || items.length === 0) {
      return { ok: true, moved: 0, updated: 0, removed: 0, skipped: 0 };
    }

    const srcVals = shSrc.getDataRange().getValues();
    if (srcVals.length < 2) return { ok: false, message: "RGB_Data has no rows." };

    const srcHdr = srcVals[0].map(h => String(h ?? ""));
    const srcIdx = _buildHdrIndex_(srcHdr);

    const sDid = srcIdx["device_id"];
    const sTid = srcIdx["test_id"];
    const sDat = srcIdx["test_date"] ?? srcIdx["date"] ?? srcIdx["datetime"];
    const sBat = srcIdx["qcbatch_id"] ?? srcIdx["qc_batch"];

    if (sDid == null || sTid == null || sDat == null) {
      return { ok: false, message: "RGB_Data must contain Device_ID, Test_ID, Test_date." };
    }

    // --- Ensure QC_Data schema == RGB_Data schema (upgrade if needed) ---
    const wantCols = srcHdr.length;

    const dstLastRow = shDst.getLastRow();
    const dstLastCol = shDst.getLastColumn();

    if (dstLastRow < 1 || dstLastCol < 1) {
      shDst.clear();
      shDst.getRange(1, 1, 1, wantCols).setValues([srcHdr]);
      shDst.setFrozenRows(1);
    } else {
      const dstHdrExisting = shDst
        .getRange(1, 1, 1, Math.max(dstLastCol, wantCols))
        .getValues()[0]
        .map(h => String(h ?? ""));

      const aligned = (dstHdrExisting.length >= wantCols) &&
        (dstHdrExisting.slice(0, wantCols).join("|") === srcHdr.join("|"));

      // Write canonical header
      shDst.getRange(1, 1, 1, wantCols).setValues([srcHdr]);
      shDst.setFrozenRows(1);

      // If sheet previously had fewer cols, pad existing rows
      if (!aligned && dstLastRow >= 2) {
        const oldData = shDst.getRange(2, 1, dstLastRow - 1, dstLastCol).getValues();
        const padded = oldData.map(r => {
          const out = r.slice(0, wantCols);
          while (out.length < wantCols) out.push("");
          return out;
        });
        shDst.getRange(2, 1, padded.length, wantCols).setValues(padded);
      }
    }

    const dstVals = shDst.getDataRange().getValues();
    const dstHdr = dstVals[0].map(h => String(h ?? ""));
    const dstIdx = _buildHdrIndex_(dstHdr);

    const dDid = dstIdx["device_id"];
    const dTid = dstIdx["test_id"];
    const dDat = dstIdx["test_date"] ?? dstIdx["date"] ?? dstIdx["datetime"];
    const dBat = dstIdx["qcbatch_id"] ?? dstIdx["qc_batch"];

    if (dDid == null || dTid == null || dDat == null) {
      return { ok: false, message: "QC_Data must contain Device_ID, Test_ID, Test_date after schema sync." };
    }
    if (dBat == null && sBat == null) return { ok: false, message: "Missing QCBatch_ID column in schema." };

    // ---------- Canonical date key (stable across Date objects and display strings) ----------
    const _canonDateKey = (v) => {
      // Use your existing helper if present
      if (typeof _dateKey_ === "function") {
        const k = _dateKey_(v);
        if (k) return k; // "yyyy-MM-dd HH:mm"
      }
      // Fallback: try parse
      if (typeof _parseAnyDate_ === "function") {
        const d = _parseAnyDate_(v);
        if (d && !isNaN(d.getTime())) {
          return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
        }
      }
      // Last resort: normalize pipe to space and trim
      const s0 = String(v ?? "").trim();
      return s0.includes("|") ? s0.replace(/\s*\|\s*/g, " ").trim() : s0;
    };

    const key3 = (did, tid, dt) =>
      `${String(did ?? "").trim()}|${String(tid ?? "").trim()}|${_canonDateKey(dt)}`;

    // Build src map by Device+Test+Date
    const srcMap = new Map();
    for (let r = 1; r < srcVals.length; r++) {
      const row = srcVals[r];
      const k = key3(row[sDid], row[sTid], row[sDat]);
      if (k && !srcMap.has(k)) srcMap.set(k, { rowNum: r + 1, row });
    }

    // Build dst map (existing rowNum)
    const dstMap = new Map();
    for (let r = 1; r < dstVals.length; r++) {
      const row = dstVals[r];
      const k = key3(row[dDid], row[dTid], row[dDat]);
      if (k && !dstMap.has(k)) dstMap.set(k, r + 1);
    }

    const appends = [];
    const updates = [];
    const deleteRows = [];
    let moved = 0, updated = 0, skipped = 0;

    items.forEach(req => {
      const did = req?.Device_ID ?? req?.did ?? req?.device_id ?? "";
      const tid = req?.Test_ID ?? req?.tid ?? req?.test_id ?? "";
      const dt  = req?.Test_date ?? req?.test_date ?? req?.time ?? req?.date ?? req?.datetime ?? "";

      const batch = String(
        req?.QCBatch_ID ?? req?.qcBatchId ?? req?.QC_Batch ?? req?.batch ?? "Default"
      ).trim() || "Default";

      const k = key3(did, tid, dt);
      const hit = srcMap.get(k);
      if (!hit) { skipped++; return; }

      const out = hit.row.slice(0, wantCols);
      while (out.length < wantCols) out.push("");

      // Force batch
      const batCol = (dBat != null) ? dBat : sBat;
      if (batCol != null) out[batCol] = batch;

      const existingRowNum = dstMap.get(k);
      if (existingRowNum) {
        updates.push({ rowNum: existingRowNum, row: out });
        updated++;
      } else {
        appends.push(out);
        moved++;
      }

      deleteRows.push(hit.rowNum);
    });

    updates.forEach(u => shDst.getRange(u.rowNum, 1, 1, wantCols).setValues([u.row]));
    if (appends.length) shDst.getRange(shDst.getLastRow() + 1, 1, appends.length, wantCols).setValues(appends);

    // Format Test_date display
    shDst.getRange(2, dDat + 1, Math.max(0, shDst.getLastRow() - 1), 1).setNumberFormat("yyyy-mm-dd | HH:mm");

    // CUT from RGB_Data
    deleteRows.sort((a, b) => b - a).forEach(rn => shSrc.deleteRow(rn));

    return { ok: true, moved, updated, removed: deleteRows.length, skipped };

  } catch (e) {
    return { ok: false, message: String(e?.message || e) };
  } finally {
    lock.releaseLock();
  }
}



function syncMoveDataToRGB(reqRows) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const shSrc = ss.getSheetByName("QC_Data");
    const shDst = ss.getSheetByName("RGB_Data");
    if (!shSrc || !shDst) return { ok: false, message: "Missing QC_Data or RGB_Data sheet." };

    const items = Array.isArray(reqRows) ? reqRows : JSON.parse(reqRows || "[]");
    if (!Array.isArray(items) || items.length === 0) {
      return { ok: true, moved: 0, updated: 0, removed: 0, skipped: 0 };
    }

    const dstVals = shDst.getDataRange().getValues();
    if (dstVals.length < 1) return { ok: false, message: "RGB_Data has no header row." };

    const dstHdr = dstVals[0].map(h => String(h ?? ""));
    const dIdx = _buildHdrIndex_(dstHdr);

    const dDid = dIdx["device_id"];
    const dTid = dIdx["test_id"];
    const dDat = dIdx["test_date"] ?? dIdx["date"] ?? dIdx["datetime"];

    if (dDid == null || dTid == null || dDat == null) {
      return { ok: false, message: "RGB_Data must contain Device_ID, Test_ID, Test_date." };
    }

    const srcVals = shSrc.getDataRange().getValues();
    if (srcVals.length < 2) return { ok: true, moved: 0, updated: 0, removed: 0, skipped: items.length };

    const srcHdr = srcVals[0].map(h => String(h ?? ""));
    const sIdx = _buildHdrIndex_(srcHdr);

    const sDid = sIdx["device_id"];
    const sTid = sIdx["test_id"];
    const sDat = sIdx["test_date"] ?? sIdx["date"] ?? sIdx["datetime"];

    if (sDid == null || sTid == null || sDat == null) {
      return { ok: false, message: "QC_Data must contain Device_ID, Test_ID, Test_date." };
    }

    // ---------- Canonical date key ----------
    const _canonDateKey = (v) => {
      if (typeof _dateKey_ === "function") {
        const k = _dateKey_(v);
        if (k) return k;
      }
      if (typeof _parseAnyDate_ === "function") {
        const d = _parseAnyDate_(v);
        if (d && !isNaN(d.getTime())) {
          return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
        }
      }
      const s0 = String(v ?? "").trim();
      return s0.includes("|") ? s0.replace(/\s*\|\s*/g, " ").trim() : s0;
    };

    const key3 = (did, tid, dt) =>
      `${String(did ?? "").trim()}|${String(tid ?? "").trim()}|${_canonDateKey(dt)}`;

    // Build QC map
    const srcMap = new Map();
    for (let r = 1; r < srcVals.length; r++) {
      const row = srcVals[r];
      const k = key3(row[sDid], row[sTid], row[sDat]);
      if (k && !srcMap.has(k)) srcMap.set(k, { rowNum: r + 1, row });
    }

    // Build RGB existing key->rowNum
    const dstKeyToRowNum = new Map();
    for (let r = 1; r < dstVals.length; r++) {
      const row = dstVals[r];
      const k = key3(row[dDid], row[dTid], row[dDat]);
      if (k && !dstKeyToRowNum.has(k)) dstKeyToRowNum.set(k, r + 1);
    }

    // Map headers by normalized key
    const srcByNorm = {};
    srcHdr.forEach((h, i) => { srcByNorm[_normHdrKey_(h)] = i; });
    const dstByNorm = {};
    dstHdr.forEach((h, i) => { dstByNorm[_normHdrKey_(h)] = i; });

    const wantCols = dstHdr.length;
    const appends = [];
    const updates = [];
    const deleteRows = [];
    let skipped = 0, moved = 0, updated = 0;

    const setIfBlank = (out, normKey, val) => {
      const j = dstByNorm[normKey];
      if (j == null) return;
      if (out[j] === "" || out[j] == null) out[j] = val;
    };

    items.forEach(it => {
      const did = it?.Device_ID ?? it?.did ?? it?.device_id ?? "";
      const tid = it?.Test_ID ?? it?.tid ?? it?.test_id ?? "";
      const dt  = it?.Test_date ?? it?.test_date ?? it?.time ?? it?.date ?? it?.datetime ?? "";

      const k = key3(did, tid, dt);
      const hit = srcMap.get(k);
      if (!hit) { skipped++; return; }

      const srcRow = hit.row;
      const out = new Array(wantCols).fill("");

      // Copy matching columns by normalized header key
      Object.keys(dstByNorm).forEach(nk => {
        const dj = dstByNorm[nk];
        const si = srcByNorm[nk];
        if (dj != null && si != null) out[dj] = srcRow[si];
      });

      // Force keys from QC row
      out[dDid] = srcRow[sDid];
      out[dTid] = srcRow[sTid];
      out[dDat] = srcRow[sDat];

      // Ensure defaults only if blank
      setIfBlank(out, "client_id", "Default");
      setIfBlank(out, "farm_id", "Default");
      setIfBlank(out, "prodbatch_id", "Default");
      setIfBlank(out, "qcbatch_id", "Default");

      const existingRowNum = dstKeyToRowNum.get(k);
      if (existingRowNum) {
        updates.push({ rowNum: existingRowNum, row: out });
        updated++;
      } else {
        appends.push(out);
        moved++;
      }

      deleteRows.push(hit.rowNum);
    });

    updates.forEach(u => shDst.getRange(u.rowNum, 1, 1, wantCols).setValues([u.row]));
    if (appends.length) shDst.getRange(shDst.getLastRow() + 1, 1, appends.length, wantCols).setValues(appends);

    // Format Test_date display
    shDst.getRange(2, dDat + 1, Math.max(0, shDst.getLastRow() - 1), 1).setNumberFormat("yyyy-mm-dd | HH:mm");

    // CUT from QC_Data
    deleteRows.sort((a, b) => b - a).forEach(rn => shSrc.deleteRow(rn));

    return { ok: true, moved, updated, removed: deleteRows.length, skipped };

  } catch (e) {
    return { ok: false, message: String(e?.message || e) };
  } finally {
    lock.releaseLock();
  }
}








function deleteFromQCData(payload) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("QC_Data");
  if (!sh) return { ok: true, deleted: 0 };

  const rowsIn = (typeof payload === "string") ? JSON.parse(payload) : payload;
  if (!Array.isArray(rowsIn) || rowsIn.length === 0) return { ok: true, deleted: 0 };

  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);

  const didIdx = col["device_id"];
  const tidIdx = col["test_id"];
  if (didIdx == null || tidIdx == null) throw new Error("QC_Data must contain Device_ID and Test_ID");

  const kill = new Set(
    rowsIn.map(r => {
      const did = String(r.did || r.Device_ID || r.device_id || "").trim();
      const tid = String(r.tid || r.Test_ID || r.test_id || "").trim();
      return (did && tid) ? (did + "|" + tid) : null;
    }).filter(Boolean)
  );

  if (!kill.size) return { ok: true, deleted: 0 };

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return { ok: true, deleted: 0 };

  const data = sh.getRange(2, 1, lastRow - 1, sh.getLastColumn()).getValues();
  const toDelete = [];

  for (let i = 0; i < data.length; i++) {
    const did = String(data[i][didIdx] || "").trim();
    const tid = String(data[i][tidIdx] || "").trim();
    if (kill.has(did + "|" + tid)) toDelete.push(i + 2);
  }

  toDelete.sort((a, b) => b - a).forEach(rn => sh.deleteRow(rn));
  return { ok: true, deleted: toDelete.length };
}

function deleteFromRGBData(payload) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("RGB_Data");
  if (!sh) return { ok: true, deleted: 0 };

  const rowsIn = (typeof payload === "string") ? JSON.parse(payload) : payload;
  if (!Array.isArray(rowsIn) || rowsIn.length === 0) return { ok: true, deleted: 0 };

  const headers = srvrGetHeaders(sh);
  const col = srvrLowerMap(headers);

  const didIdx = col["device_id"];
  const tidIdx = col["test_id"];
  if (didIdx == null || tidIdx == null) throw new Error("RGB_Data must contain Device_ID and Test_ID");

  const kill = new Set(
    rowsIn.map(r => {
      const did = String(r.did || r.Device_ID || r.device_id || "").trim();
      const tid = String(r.tid || r.Test_ID || r.test_id || "").trim();
      return (did && tid) ? (did + "|" + tid) : null;
    }).filter(Boolean)
  );

  if (!kill.size) return { ok: true, deleted: 0 };

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return { ok: true, deleted: 0 };

  const data = sh.getRange(2, 1, lastRow - 1, sh.getLastColumn()).getValues();
  const toDelete = [];

  for (let i = 0; i < data.length; i++) {
    const did = String(data[i][didIdx] || "").trim();
    const tid = String(data[i][tidIdx] || "").trim();
    if (kill.has(did + "|" + tid)) toDelete.push(i + 2);
  }

  toDelete.sort((a, b) => b - a).forEach(rn => sh.deleteRow(rn));
  return { ok: true, deleted: toDelete.length };
}




function getNutrientManagerConfig(clientId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const cid = clientId || 'Default';

  // Helper: getDataByHeaders returns an array of row arrays; we need indices.
  function loadSheetWithMap(sheetName, requestedHeaders) {
    const rows = getDataByHeaders(ss, sheetName, requestedHeaders) || [];
    // getDataByHeaders already reorders columns to match requestedHeaders,
    // so row[0] is requestedHeaders[0], row[1] is requestedHeaders[1], etc.
    return { headers: requestedHeaders, rows: rows };
  }

  // 1) Rating schemes from SoilFertilityRatings
  const fert = loadSheetWithMap('SoilFertilityRatings', [
    'ClientID', 'RatingSchemeID', 'Parameter', 'ClassName', 'ClassOrder',
    'MinValue', 'MaxValue', 'Unit', 'Notes'
  ]);

  const idxClientF = fert.headers.indexOf('ClientID');
  const idxSchemeF = fert.headers.indexOf('RatingSchemeID');

  const ratingSchemesMap = {};
  fert.rows.forEach(function (row) {
    const rowClient = row[idxClientF] ? String(row[idxClientF]).trim() : '';
    if (rowClient !== cid) return;
    const rs = row[idxSchemeF] ? String(row[idxSchemeF]).trim() : '';
    if (!rs) return;
    ratingSchemesMap[rs] = true;
  });

  const ratingSchemes = Object.keys(ratingSchemesMap).sort().map(function (id) {
    return { id: id, label: id };
  });

  // 2) Crops from NutrientCrops (no idxDefY)
  const cropsSheet = loadSheetWithMap('NutrientCrops', [
    'ClientID', 'CropID', 'CropName', 'Category', 'SeasonType',
    'YieldUnit', 'RootDepthClass', 'ActiveFlag', 'Notes'
  ]);

  const idxClientC = cropsSheet.headers.indexOf('ClientID');
  const idxCropId = cropsSheet.headers.indexOf('CropID');
  const idxCropName = cropsSheet.headers.indexOf('CropName');
  const idxCat = cropsSheet.headers.indexOf('Category');
  const idxSeason = cropsSheet.headers.indexOf('SeasonType');
  const idxYUnit = cropsSheet.headers.indexOf('YieldUnit');
  const idxActive = cropsSheet.headers.indexOf('ActiveFlag');

  const crops = cropsSheet.rows
    .filter(function (row) {
      const rowClient = row[idxClientC] ? String(row[idxClientC]).trim() : '';
      if (rowClient !== cid) return false;
      const active = row[idxActive] ? String(row[idxActive]).toLowerCase().trim() : 'yes';
      return active !== 'no';
    })
    .map(function (row) {
      return {
        cropId: row[idxCropId] ? String(row[idxCropId]).trim() : '',
        name: row[idxCropName] ? String(row[idxCropName]).trim() : '',
        category: row[idxCat] || '',
        seasonType: row[idxSeason] || '',
        // defaultTargetYield is now driven by STCR sheet, so keep blank or drop this field
        defaultTargetYield: '',
        yieldUnit: row[idxYUnit] || 't/ha'
      };
    })
    .filter(function (c) { return c.cropId && c.name; });

  // 3) Methods from NutrientMethods
  const methodsSheet = loadSheetWithMap('NutrientMethods', [
    'ClientID', 'MethodID', 'MethodName', 'Description', 'ActiveFlag'
  ]);

  const idxClientM = methodsSheet.headers.indexOf('ClientID');
  const idxMid = methodsSheet.headers.indexOf('MethodID');
  const idxMName = methodsSheet.headers.indexOf('MethodName');
  const idxMDesc = methodsSheet.headers.indexOf('Description');
  const idxMActive = methodsSheet.headers.indexOf('ActiveFlag');

  const methods = methodsSheet.rows
    .filter(function (row) {
      const rowClient = row[idxClientM] ? String(row[idxClientM]).trim() : '';
      if (rowClient !== cid) return false;
      const active = row[idxMActive] ? String(row[idxMActive]).toLowerCase().trim() : 'yes';
      return active !== 'no';
    })
    .map(function (row) {
      return {
        methodId: row[idxMid] ? String(row[idxMid]).trim() : '',
        name: row[idxMName] ? String(row[idxMName]).trim() : '',
        description: row[idxMDesc] || ''
      };
    })
    .filter(function (m) { return m.methodId && m.name; });

  return {
    clientId: cid,
    ratingSchemes: ratingSchemes,
    crops: crops,
    methods: methods
  };
}


function getNutrientPlanForTest(testId, deviceId, clientId, ratingSchemeId, methodId, cropId, targetYield) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  ensureSoilTestResultsSheet_();
  const sh = ss.getSheetByName('SoilTest_Results');
  ensureColumnWithDefault_(sh, 1, 'Crop', 'Wheat');
  const data = sh.getDataRange().getValues();
  if (data.length < 2) return { summary: [], stages: [], planTotals: { N: 0, P: 0, K: 0 } };

  const headers = data[0].map(String);
  const idxTestId = getHeaderIndex_(headers, 'Test_ID');
  const idxClient = headers.indexOf('ClientID');
  const idxCrop = headers.indexOf('Crop');

  let rowObj = null;
  for (let r = 1; r < data.length; r++) {
    if (String(data[r][idxTestId]) === String(testId)) {
      rowObj = {};
      headers.forEach((h, i) => rowObj[h] = data[r][i]);
      break;
    }
  }
  if (!rowObj) return { summary: [], stages: [], planTotals: { N: 0, P: 0, K: 0 } };

  // Fallbacks from sheet if UI didn’t pass them
  const effectiveClientId = clientId || rowObj['ClientID'] || 'Default';
  const effectiveCropId = cropId || rowObj['Crop'];

  // Rating schemes table
  const fert = getDataByHeaders(ss, 'SoilFertilityRatings', [
    'ClientID', 'RatingSchemeID', 'Parameter', 'ClassName', 'ClassOrder',
    'MinValue', 'MaxValue', 'Unit', 'Notes'
  ]) || [];

  const summary = [];
  ['pH', 'EC', 'OC', 'Avail_N', 'Avail_P', 'Avail_K', 'Avail_S', 'Zn', 'Fe', 'Mn', 'Cu', 'B'].forEach(paramCol => {
    const soilVal = rowObj[paramCol];
    if (soilVal === '' || soilVal === null || soilVal === undefined) return;
    let paramName = paramCol.replace('Avail_', ''); // pH, EC, OC, N, P, K, S, Zn, Fe, Mn, Cu, B

    // Map to actual Parameter names in SoilFertilityRatings
    let ratingParamKey = paramName;
    if (paramName === 'P') ratingParamKey = 'P2O5';
    if (paramName === 'K') ratingParamKey = 'K2O';
    // Add more mappings here if your sheet uses other labels

    const matches = fert.filter(r =>
      String(r[0]) === String(effectiveClientId) &&
      String(r[1]) === String(ratingSchemeId) &&
      String(r[2]) === String(ratingParamKey)
    );

    let className = '', unit = '', notes = '';
    matches.forEach(r => {
      const min = r[5], max = r[6];
      if ((min === '' || soilVal >= min) && (max === '' || soilVal <= max)) {
        className = r[3];
        unit = r[7];
        notes = r[8];
      }
    });

    // TEMP baseDose so stages are non‑zero (replace with NutrientTargets later)
    let baseDose = 0;
    if (paramName === 'N') baseDose = 120;
    if (paramName === 'P') baseDose = 60;
    if (paramName === 'K') baseDose = 120;

    summary.push({
      nutrient: paramName,
      soilValue: soilVal,
      unit: unit || '-',
      className: className || '-',
      notes: notes || '',
      baseDose: baseDose,
      doseMultiplier: 1
    });
  });

  Logger.log('getNutrientPlanForTest summary: ' + JSON.stringify(summary));

  const stages = buildGeneralStages_(
    summary,
    effectiveCropId,
    effectiveClientId,
    methodId,
    ratingSchemeId,
    targetYield
  );

  Logger.log('getNutrientPlanForTest stages.length=' + stages.length);

  // Compute total N, P, K (kg/ha) across all stages
  var totalNkgPerHa = 0;
  var totalPkgPerHa = 0;
  var totalKkgPerHa = 0;

  stages.forEach(function (st) {
    if (st.nRate) totalNkgPerHa += Number(st.nRate) || 0;
    if (st.pRate) totalPkgPerHa += Number(st.pRate) || 0;
    if (st.kRate) totalKkgPerHa += Number(st.kRate) || 0;
  });

  return {
    summary: summary,
    stages: stages,
    planTotals: {
      N: totalNkgPerHa,
      P: totalPkgPerHa,
      K: totalKkgPerHa
    }
  };
}


function buildGeneralStages_(summary, cropId, clientId, methodId, ratingSchemeId, targetYield) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  Logger.log('buildGeneralStages_ inputs: clientId=%s cropId=%s methodId=%s ratingSchemeId=%s targetYield=%s',
    clientId, cropId, methodId, ratingSchemeId, targetYield);
  Logger.log('buildGeneralStages_ summary: ' + JSON.stringify(summary));

  const stSheet = ss.getSheetByName('NutrientStages');
  const stageRows = [];
  const nFrac = {}, pFrac = {}, kFrac = {};
  const orderedStages = [];

  if (stSheet) {
    const stData = stSheet.getDataRange().getValues();
    Logger.log('NutrientStages header row: ' + JSON.stringify(stData[0]));
    if (stData.length > 1) {
      const h = stData[0].map(String);
      const idxClient = h.indexOf('ClientID');
      const idxCrop = h.indexOf('CropID');
      const idxStageId = h.indexOf('StageID');
      const idxStageName = h.indexOf('StageName');
      const idxSeq = h.indexOf('SequenceNo');
      const idxNFrac = h.indexOf('N_FractionPct');
      const idxPFrac = h.indexOf('P2O5_FractionPct');
      const idxKFrac = h.indexOf('K2O_FractionPct');

      Logger.log('NutrientStages idxClient=%s idxCrop=%s idxNFrac=%s idxPFrac=%s idxKFrac=%s',
        idxClient, idxCrop, idxNFrac, idxPFrac, idxKFrac);

      for (let r = 1; r < stData.length; r++) {
        const row = stData[r];
        if (String(row[idxClient]) === String(clientId) &&
          String(row[idxCrop]) === String(cropId)) {
          const stageName = String(row[idxStageName] || row[idxStageId] || '').trim();
          const seq = Number(row[idxSeq] || 0);
          stageRows.push({
            stageName: stageName,
            seq: seq,
            nPct: Number(row[idxNFrac] || 0),
            pPct: Number(row[idxPFrac] || 0),
            kPct: Number(row[idxKFrac] || 0)
          });
        }
      }

      Logger.log('Matched stageRows: ' + JSON.stringify(stageRows));

      stageRows.sort(function (a, b) { return a.seq - b.seq; });
      stageRows.forEach(function (st) {
        if (!st.stageName) return;
        orderedStages.push(st.stageName);
        if (st.nPct) nFrac[st.stageName] = st.nPct / 100;
        if (st.pPct) pFrac[st.stageName] = st.pPct / 100;
        if (st.kPct) kFrac[st.stageName] = st.kPct / 100;
      });
    }
  }

  Logger.log('orderedStages after NutrientStages: ' + JSON.stringify(orderedStages));

  if (orderedStages.length === 0) {
    orderedStages.push('Basal', 'Vegetative', 'Flowering');
    Logger.log('No matching NutrientStages rows; using fallback stages.');
  }

  const selectors = buildNutrientSourceSelectors_(clientId);
  Logger.log('selectors keys: ' + Object.keys(selectors || {}));

  const stages = [];
  const nFromPByStage = {};
  const kFromPByStage = {};
  const pFertByStage = {};

  summary.forEach(function (s) {
    let label = s.nutrient;
    let key = s.nutrient;

    if (key === 'P') key = 'P2O5';
    if (key === 'K') key = 'K2O';
    if (label === 'P') label = 'P₂O₅';
    if (label === 'K') label = 'K₂O';

    const base = Number(s.baseDose) || 0;
    const mult = Number(s.doseMultiplier) || 1.0;
    const totalDose = base * mult;

    orderedStages.forEach(function (stageName) {
      let fracMap = null;
      if (key === 'N') fracMap = nFrac;
      else if (key === 'P2O5') fracMap = pFrac;
      else if (key === 'K2O') fracMap = kFrac;

      let frac = 0;
      if (fracMap && Object.prototype.hasOwnProperty.call(fracMap, stageName)) {
        frac = fracMap[stageName];
      }

      const dose = frac === 0
        ? 0
        : Math.round(totalDose * frac * 10) / 10;

      if (dose > 0) {
        Logger.log('Dose for %s at %s: base=%s mult=%s frac=%s dose=%s',
          key, stageName, base, mult, frac, dose);
      }

      if (key === 'P2O5' && dose > 0) {
        const stageKey = stageName.toUpperCase();
        let pList = selectors.pByStage[stageKey] || [];

        if (pList.length === 0 && selectors.pByStage.BASAL) {
          pList = selectors.pByStage.BASAL;
        }
        if (pList.length === 0) {
          Object.keys(selectors.pByStage).forEach(function (k) {
            (selectors.pByStage[k] || []).forEach(function (p) { pList.push(p); });
          });
        }

        const src = pList[0] || null;
        if (src && src.P2O5 > 0) {
          const gradeP = src.P2O5;
          const kgProductPerHa = dose / (gradeP / 100);

          const nPercent = Number(src.N || 0);
          const kPercent = Number(src.K2O || 0);

          const nFromThis = kgProductPerHa * (nPercent / 100);
          const kFromThis = kgProductPerHa * (kPercent / 100);

          if (!nFromPByStage[stageName]) nFromPByStage[stageName] = 0;
          if (!kFromPByStage[stageName]) kFromPByStage[stageName] = 0;

          nFromPByStage[stageName] += nFromThis;
          kFromPByStage[stageName] += kFromThis;

          if (!pFertByStage[stageName]) pFertByStage[stageName] = [];
          pFertByStage[stageName].push({
            src: src,
            kgProductPerHa: kgProductPerHa
          });
        }
      }

      stages.push({
        stage: stageName,
        nutrient: label,
        timing: '',
        method: '',
        dose: dose,
        unit: 'kg/ha',
        sourceMix: '',
        productQty: '',
        costPerHa: '',
        details: '',
        flags: ''
      });
    });
  });

  Logger.log('After FIRST PASS, stages.length=' + stages.length);

  const nTargetByStage = {};
  const kTargetByStage = {};

  summary.forEach(function (s) {
    let key = s.nutrient;
    if (key === 'P') key = 'P2O5';
    if (key === 'K') key = 'K2O';

    const base = Number(s.baseDose) || 0;
    const mult = Number(s.doseMultiplier) || 1.0;
    const totalDose = base * mult;

    orderedStages.forEach(function (stageName) {
      let fracMap = null;
      if (key === 'N') fracMap = nFrac;
      else if (key === 'K2O') fracMap = kFrac;

      if (!fracMap) return;

      const frac = Object.prototype.hasOwnProperty.call(fracMap, stageName)
        ? fracMap[stageName]
        : 0;
      if (frac === 0) return;

      const dose = Math.round(totalDose * frac * 10) / 10;

      if (key === 'N') {
        if (!nTargetByStage[stageName]) nTargetByStage[stageName] = 0;
        nTargetByStage[stageName] += dose;
      }
      if (key === 'K2O') {
        if (!kTargetByStage[stageName]) kTargetByStage[stageName] = 0;
        kTargetByStage[stageName] += dose;
      }
    });
  });

  function pickStraightSource(listByStage, stageName, keyField) {
    const stageKey = stageName.toUpperCase();
    let list = (listByStage[stageKey] || []).filter(function (s) {
      return Number(s[keyField] || 0) > 0;
    });
    if (list.length === 0 && listByStage.BASAL) {
      list = (listByStage.BASAL || []).filter(function (s) {
        return Number(s[keyField] || 0) > 0;
      });
    }
    if (list.length === 0) {
      Object.keys(listByStage).forEach(function (k) {
        (listByStage[k] || []).forEach(function (src) {
          if (Number(src[keyField] || 0) > 0) list.push(src);
        });
      });
    }
    return list[0] || null;
  }

  const nByStage = selectors.nByStage || {};
  const kByStage = selectors.kByStage || {};

  orderedStages.forEach(function (stageName) {
    const pList = pFertByStage[stageName] || [];
    pList.forEach(function (pf) {
      const src = pf.src;
      const kgProductPerHa = pf.kgProductPerHa;
      const unitSize = src.unitSize || 1;
      const unitsPerHa = kgProductPerHa / unitSize;
      const cost = unitsPerHa * (src.pricePerUnit || 0);

      stages.push({
        stage: stageName,
        nutrient: 'P₂O₅',
        timing: '',
        method: '',
        dose: '',
        unit: '',
        sourceMix: src.name,
        productQty: unitsPerHa.toFixed(2) + ' ' + src.unitBasis,
        costPerHa: cost.toFixed(0) + ' ' + src.currency,
        details: 'FERT: P complex (DAP or similar)',
        flags: ''
      });
    });

    const nTarget = nTargetByStage[stageName] || 0;
    const nFromP = nFromPByStage[stageName] || 0;
    const nStraight = nTarget - nFromP;
    if (nStraight > 0.05) {
      const nSrc = pickStraightSource(nByStage, stageName, 'N');
      if (nSrc && Number(nSrc.N || 0) > 0) {
        const nGrade = Number(nSrc.N);
        const kgProductPerHaN = nStraight / (nGrade / 100);
        const unitSizeN = nSrc.unitSize || 1;
        const unitsPerHaN = kgProductPerHaN / unitSizeN;
        const costN = unitsPerHaN * (nSrc.pricePerUnit || 0);

        stages.push({
          stage: stageName,
          nutrient: 'N',
          timing: '',
          method: '',
          dose: '',
          unit: '',
          sourceMix: nSrc.name,
          productQty: unitsPerHaN.toFixed(2) + ' ' + nSrc.unitBasis,
          costPerHa: costN.toFixed(0) + ' ' + nSrc.currency,
          details: 'FERT: Straight N (Urea) to close balance after P sources',
          flags: ''
        });
      }
    }

    const kTarget = kTargetByStage[stageName] || 0;
    const kFromP = kFromPByStage[stageName] || 0;
    const kStraight = kTarget - kFromP;
    if (kStraight > 0.05) {
      const kSrc = pickStraightSource(kByStage, stageName, 'K2O');
      if (kSrc && Number(kSrc.K2O || 0) > 0) {
        const kGrade = Number(kSrc.K2O);
        const kgProductPerHaK = kStraight / (kGrade / 100);
        const unitSizeK = kSrc.unitSize || 1;
        const unitsPerHaK = kgProductPerHaK / unitSizeK;
        const costK = unitsPerHaK * (kSrc.pricePerUnit || 0);

        stages.push({
          stage: stageName,
          nutrient: 'K₂O',
          timing: '',
          method: '',
          dose: '',
          unit: '',
          sourceMix: kSrc.name,
          productQty: unitsPerHaK.toFixed(2) + ' ' + kSrc.unitBasis,
          costPerHa: costK.toFixed(0) + ' ' + kSrc.currency,
          details: 'FERT: Straight K (MOP) to close balance after P sources',
          flags: ''
        });
      }
    }
  });

  Logger.log('buildGeneralStages_ returning stages.length=' + stages.length);
  return stages;
}




function logNutrientBalance_(testId, stages) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = 'NutrientDebug';
  let sh = ss.getSheetByName(sheetName);
  if (!sh) {
    sh = ss.insertSheet(sheetName);
    sh.appendRow([
      'Timestamp',
      'TestID',
      'Stage',
      'Nutrient',
      'Target_kg_ha',
      'Supplied_kg_ha',
      'Diff_kg_ha',
      'FertilizerBreakdown'
    ]);
  }

  // Maps: stage -> nutrient -> value
  const target = {};
  const supplied = {};
  const fertText = {};

  stages.forEach(function (row) {
    const stage = row.stage || '';
    const nut = row.nutrient || '';

    if (!stage || !nut) return;

    // Init maps
    if (!target[stage]) target[stage] = {};
    if (!supplied[stage]) supplied[stage] = {};
    if (!fertText[stage]) fertText[stage] = {};

    // Nutrient rows: details empty => target only
    if (!row.details) {
      const dose = Number(row.dose || 0);
      if (!isNaN(dose)) {
        target[stage][nut] = (target[stage][nut] || 0) + dose;
      }
      return;
    }

    // Fertilizer rows: details start with "FERT:"
    if (String(row.details).indexOf('FERT:') !== 0) return;

    const srcName = String(row.sourceMix || '');
    const qtyStr = String(row.productQty || ''); // e.g. "1.74 bag"
    const qtyNum = parseFloat(qtyStr);          // units/ha (bags/ha)
    if (!srcName || isNaN(qtyNum)) return;

    // Look up nutrient analysis and unit size from NutrientSources
    const list = getNutrientSources_('Default'); // or pass clientId later
    const src = (list || []).find(function (s) { return s.name === srcName; });
    if (!src) return;

    const unitSize = src.unitSize || 1; // kg per unit (e.g. per bag)
    const kgPerHa = qtyNum * unitSize;

    const nPct = Number(src.N || 0);
    const pPct = Number(src.P2O5 || 0);
    const kPct = Number(src.K2O || 0);

    function addSupplied(stageKey, nutrientKey, kg) {
      if (!supplied[stageKey][nutrientKey]) supplied[stageKey][nutrientKey] = 0;
      supplied[stageKey][nutrientKey] += kg;
    }

    // Map fertilizer contribution to nutrients
    if (nPct > 0) {
      addSupplied(stage, 'N', kgPerHa * (nPct / 100));
    }
    if (pPct > 0) {
      addSupplied(stage, 'P₂O₅', kgPerHa * (pPct / 100));
    }
    if (kPct > 0) {
      addSupplied(stage, 'K₂O', kgPerHa * (kPct / 100));
    }

    // Track text breakdown per Stage×Nutrient
    ['N', 'P₂O₅', 'K₂O'].forEach(function (nutKey) {
      let contributes = false;
      if (nutKey === 'N' && nPct > 0) contributes = true;
      if (nutKey === 'P₂O₅' && pPct > 0) contributes = true;
      if (nutKey === 'K₂O' && kPct > 0) contributes = true;
      if (!contributes) return;

      if (!fertText[stage][nutKey]) fertText[stage][nutKey] = [];
      fertText[stage][nutKey].push(srcName + ' ' + qtyStr);
    });
  });

  const now = new Date();
  const rowsOut = [];

  Object.keys(target).forEach(function (stage) {
    Object.keys(target[stage]).forEach(function (nut) {
      const tgt = target[stage][nut] || 0;
      const sup = (supplied[stage] && supplied[stage][nut]) ? supplied[stage][nut] : 0;
      const diff = tgt - sup;
      const breakdownArr = (fertText[stage] && fertText[stage][nut]) ? fertText[stage][nut] : [];
      rowsOut.push([
        now,
        testId,
        stage,
        nut,
        Number(tgt.toFixed(2)),
        Number(sup.toFixed(2)),
        Number(diff.toFixed(2)),
        breakdownArr.join(' + ')
      ]);
    });
  });

  if (rowsOut.length > 0) {
    sh.getRange(sh.getLastRow() + 1, 1, rowsOut.length, rowsOut[0].length).setValues(rowsOut);
  }
}




// --- COLUMN MAPPING ---
const COL_MAP = [
  { k: 'ammonium', t: 'Amnm_n', c: 'Amnm_n_cal', b: 'B' },
  { k: 'phosphorus', t: 'Phprs', c: 'Phprs_cal', b: 'B' },
  { k: 'sulphur', t: 'Slpr', c: 'Slpr_cal', b: 'B' },
  { k: 'oc', t: 'Org_crbn', c: 'Org_crbn_cal', b: 'G' },
  { k: 'nitrate', t: 'Ntrt_n', c: 'Ntrt_n_cal', b: 'G' },
  { k: 'boron', t: 'Brn', c: 'Brn_cal', b: 'B' },
  { k: 'potassium', t: 'Potsm', c: 'Potsm_cal', b: 'B' },
  { k: 'copper', t: 'Cpr', c: 'Cpr_cal', b: 'R' },
  { k: 'zinccopper', t: 'Znc', c: 'Znc_cal', b: 'R' },
  { k: 'iron', t: 'Irn', c: 'Irn_cal', b: 'G' },
  { k: 'manganese', t: 'Mgns', c: 'Mgns_cal', b: 'G' },
  { k: 'ec', t: 'Ec', c: 'Ec_cal', b: 'K' },
  { k: 'ph', t: 'Ph', c: 'Ph_cal', b: 'K' }
];

// --- ROBUST DATA FORMATTER (UNLIMITED) ---
// Returns: did/tid/time for backward-compat + ALSO all sheet columns by header name
function getRGBDataFormatted_(ss, sheetName, isQC) {
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return [];

  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return [];

  // 1) Detect header row robustly (within first 10 rows)
  const headerRange = sheet.getRange(1, 1, Math.min(10, lastRow), sheet.getLastColumn());
  const headerValues = headerRange.getDisplayValues();

  let headerRowIndex = -1;
  for (let i = 0; i < headerValues.length; i++) {
    const rowStr = headerValues[i].join(' ').toLowerCase().replace(/[\s_-]/g, '');
    if (rowStr.includes('deviceid') && rowStr.includes('testid')) {
      headerRowIndex = i;
      break;
    }
  }
  if (headerRowIndex === -1) {
    console.error('RGB_Data header row not found');
    return [];
  }

  const headerRowNumber = headerRowIndex + 1;
  ensureColumnWithDefault_(sheet, headerRowNumber, 'Crop', 'Wheat');

  // Keep original header names (for returning exact keys like "NH4N_Abs", "NH4N_S1_B_T", etc.)
  const headersOrig = sheet.getRange(headerRowNumber, 1, 1, sheet.getLastColumn())
    .getDisplayValues()[0]
    .map(h => String(h || '').trim());

  // Normalized index for robust lookup
  const headersNorm = headersOrig.map(h => String(h).trim().toLowerCase().replace(/[\s_-]/g, ''));
  const colIdx = {};
  headersNorm.forEach((h, i) => { colIdx[h] = i; });

  const getIdx = (name) => colIdx[String(name).toLowerCase().replace(/[\s_-]/g, '')] ?? -1;

  // 2) Read rows
  const dataStartRow = headerRowIndex + 2; // assumes one blank line after header (your current convention)
  const numRows = lastRow - dataStartRow + 1;
  if (numRows <= 0) return [];

  const rows = sheet.getRange(dataStartRow, 1, numRows, sheet.getLastColumn()).getDisplayValues();

  const idxDid = getIdx('deviceid');
  const idxTid = getIdx('testid');

  // IMPORTANT: support Test_date / Datetime too (not only "date")
  const idxDate =
    [getIdx('testdate'), getIdx('test_date'), getIdx('datetime'), getIdx('date')].find(i => i >= 0) ?? -1;

  if (idxDid < 0 || idxTid < 0) {
    console.error('Missing device_id / test_id columns');
    return [];
  }

  return rows.map((row) => {
    const did = String(row[idxDid] || '').trim();
    const tid = String(row[idxTid] || '').trim();
    if (!did || !tid) return null;

    const timeVal = idxDate >= 0 ? String(row[idxDate] || '').trim() : '';

    // Base object for existing JS code paths
    const obj = {
      id: `${did}__${tid}`,
      did,
      tid,
      time: timeVal,
      raw: {} // keep for backward compatibility (even if unused in new raw-table)
    };

    // Add ALL sheet columns by their header name
    for (let c = 0; c < headersOrig.length; c++) {
      const h = headersOrig[c];
      if (!h) continue;
      obj[h] = row[c];
    }

    // Ensure canonical keys exist for UI/filtering
    obj.Device_ID = obj.Device_ID ?? did;
    obj.Test_ID = obj.Test_ID ?? tid;
    obj.Test_date = obj.Test_date ?? timeVal;
    obj.Client_ID = obj.Client_ID ?? obj.client_id ?? obj.ClientID ?? obj.clientId ?? '';
    obj.Farm_ID = obj.Farm_ID ?? obj.farm_id ?? obj.FarmID ?? obj.farmId ?? '';
    obj.crop = obj.crop ?? obj.Crop ?? obj.CropID ?? '';

    return obj;
  }).filter(Boolean);
}

function ensureColumnWithDefault_(sheet, headerRowNumber, headerName, defaultVal) {
  if (!sheet) return;
  const headerRow = sheet.getRange(headerRowNumber, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  const existingIdx = headerRow.findIndex(h => String(h || '').trim().toLowerCase() === String(headerName).toLowerCase());
  let colIndex = existingIdx >= 0 ? existingIdx + 1 : null;

  if (!colIndex) {
    colIndex = headerRow.length + 1;
    sheet.getRange(headerRowNumber, colIndex).setValue(headerName);
  }

  const lastRow = sheet.getLastRow();
  const dataStartRow = headerRowNumber + 1;
  if (lastRow < dataStartRow) return;

  const numRows = lastRow - dataStartRow + 1;
  const range = sheet.getRange(dataStartRow, colIndex, numRows, 1);
  const values = range.getDisplayValues();
  let updated = false;
  for (let i = 0; i < values.length; i++) {
    if (String(values[i][0] || '').trim() === '') {
      values[i][0] = defaultVal;
      updated = true;
    }
  }
  if (updated) range.setValues(values);
}

function findHeaderRowIndexByKeys_(sheet, keys) {
  if (!sheet) return -1;
  const lastRow = sheet.getLastRow();
  if (lastRow < 1) return -1;
  const headerRange = sheet.getRange(1, 1, Math.min(10, lastRow), sheet.getLastColumn());
  const headerValues = headerRange.getDisplayValues();
  const want = (keys || []).map(k => String(k || '').toLowerCase().replace(/[\s_-]/g, ''));
  for (let i = 0; i < headerValues.length; i++) {
    const rowNorm = headerValues[i].map(v => String(v || '').toLowerCase().replace(/[\s_-]/g, '')).join('|');
    if (want.every(k => rowNorm.includes(k))) return i + 1; // 1-indexed row
  }
  return -1;
}

function moveColumnAfter_(sheet, headerRowNumber, columnName, afterName) {
  if (!sheet) return;
  const headerRow = sheet.getRange(headerRowNumber, 1, 1, sheet.getLastColumn()).getDisplayValues()[0];
  const norm = (v) => String(v || '').trim().toLowerCase().replace(/[\s_-]/g, '');
  const colIdx = headerRow.findIndex(h => norm(h) === norm(columnName));
  const afterIdx = headerRow.findIndex(h => norm(h) === norm(afterName));
  if (colIdx < 0 || afterIdx < 0) return;
  const targetIdx = afterIdx + 1;
  if (colIdx === targetIdx) return;
  const lastRow = Math.max(sheet.getLastRow(), headerRowNumber);
  const range = sheet.getRange(1, colIdx + 1, lastRow, 1);
  sheet.moveColumns(range, targetIdx + 1);
}


function parseValue_(val, band) {
  if (val === '' || val == null) return 0;
  if (typeof val === 'number') return val;
  const strVal = String(val).trim();
  if (strVal.includes(',')) {
    const parts = strVal.split(',').map(s => parseFloat(s.trim()));
    let index = 0;
    if (band === 'G') index = 1; if (band === 'B') index = 2;
    if (parts.length > index && !isNaN(parts[index])) return parts[index];
    return parts[0] || 0;
  }
  return parseFloat(strVal) || 0;
}

function formatDate_(dateObj) {
  if (!dateObj) return '';
  if (typeof dateObj === 'string') return dateObj;
  let d;
  if (dateObj instanceof Date) d = dateObj;
  else if (typeof dateObj === 'number') d = new Date(Math.round((dateObj - 25569) * 86400 * 1000));
  else return String(dateObj);
  try {
    const year = d.getFullYear(); const month = ('0' + (d.getMonth() + 1)).slice(-2); const day = ('0' + d.getDate()).slice(-2);
    return `${year}-${month}-${day}`;
  } catch (e) { return String(dateObj); }
}


// ==========================================
// SERVICE HISTORY LOGIC (Two Rows, Locked)
// ==========================================
function saveServiceHistory(dataObj) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName('Service_History');
  if (!sheet) {
    sheet = ss.insertSheet('Service_History');
    sheet.appendRow(['Ticket_ID', 'Device_ID', 'Date', 'Status', 'Technician', 'Actions_Log', 'Feedback_File', 'Full_Data_JSON']);
  }

  const data = sheet.getDataRange().getValues();
  let draftRowIndex = -1;
  let isAlreadyClosed = false;

  // 1. Scan for Ticket ID
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]) === String(dataObj.ticketId)) {
      if (String(data[i][3]) === 'RESOLVED') isAlreadyClosed = true;
      else draftRowIndex = i + 1;
    }
  }

  if (isAlreadyClosed) return "Error: This ticket is already CLOSED and cannot be edited.";

  const rowContent = [
    dataObj.ticketId, dataObj.deviceId, new Date(), dataObj.status,
    dataObj.empId || Session.getActiveUser().getEmail(),
    dataObj.actionLogReadable, dataObj.fileUrl || '', JSON.stringify(dataObj)
  ];

  // 2. Logic: Overwrite Draft vs New Row for Close
  if (dataObj.status === 'RESOLVED') {
    sheet.appendRow(rowContent);
    return "Ticket Closed Successfully";
  } else {
    if (draftRowIndex > -1) {
      sheet.getRange(draftRowIndex, 1, 1, rowContent.length).setValues([rowContent]);
      return "Draft Updated";
    } else {
      sheet.appendRow(rowContent);
      return "Draft Created";
    }
  }
}

// ... (Rest of Savers/Loaders: saveManualEntry, saveToSheet_, etc. - Keep existing) ...
function saveToSheet_(s, r, h) { const ss = SpreadsheetApp.getActiveSpreadsheet(); let sh = ss.getSheetByName(s); if (!sh) sh = ss.insertSheet(s); if (h) sh.getRange(1, 1, 1, h.length).setValues([h]); if (sh.getLastRow() > 1) sh.getRange(2, 1, sh.getLastRow() - 1, sh.getLastColumn()).clearContent(); if (r.length) sh.getRange(2, 1, r.length, r[0].length).setValues(r); }

function saveTestSuccessCriteria(d) { saveToSheet_('Criteria', d.map(o => [o.s, o.p, o.m, o.l, o.rel, o.u, o.re, o.ac]), ['Spectro', 'Parameter', 'Metric', 'L.Limit', 'Relation', 'U.Limit', 'Reason', 'Action']); }

function saveSTVEquations(d) {
  saveToSheet_(
    'STV',
    d.map(o => [o.p, o.a, o.b, o.df1, o.df2, o.df3, o.df4]),
    ['Parameter', 'a', 'b', 'df1', 'df2', 'df3', 'df4']
  );

  const version = new Date().toISOString();
  setCurrentSTVVersion_(version);

  // NEW: append-only immutable log
  const run = appendSTVRunLog_(d, version);

  return { status: 'OK', stvVersion: version, stvRunId: run.stvRunId, stvSavedAt: run.stvSavedAt };
}



// Backend copy of cols mapping from RGB_Data headers to parameters
const STV_COLS_ = [
  { k: 'ammonium', n: 'Ammonium-N', t: 'Abs', b: 'B', csvT: 'Amnm_n', csvC: 'Amnm_n_cal' },
  { k: 'phosphorus', n: 'Phosphorus', t: 'Abs', b: 'B', csvT: 'Phprs', csvC: 'Phprs_cal' },
  { k: 'sulphur', n: 'Sulphur', t: 'Abs', b: 'B', csvT: 'Slpr', csvC: 'Slpr_cal' },
  { k: 'oc', n: 'Organic Carbon', t: 'Abs', b: 'G', csvT: 'Org_crbn', csvC: 'Org_crbn_cal' },
  { k: 'nitrate', n: 'Nitrate-N', t: 'Abs', b: 'G', csvT: 'Ntrt_n', csvC: 'Ntrt_n_cal' },
  { k: 'boron', n: 'Boron', t: 'Abs', b: 'B', csvT: 'Brn', csvC: 'Brn_cal' },
  { k: 'potassium', n: 'Potassium', t: 'Abs', b: 'B', csvT: 'Potsm', csvC: 'Potsm_cal' },
  { k: 'copper', n: 'Copper', t: 'Abs', b: 'R', csvT: 'Cpr', csvC: 'Cpr_cal' },
  { k: 'zinccopper', n: 'ZincCopper', t: 'Abs', b: 'R', csvT: 'Znc', csvC: 'Znc_cal' },
  { k: 'iron', n: 'Iron', t: 'Abs', b: 'G', csvT: 'Irn', csvC: 'Irn_cal' },
  { k: 'manganese', n: 'Manganese', t: 'Abs', b: 'G', csvT: 'Mgns', csvC: 'Mgns_cal' },
  { k: 'ec', n: 'EC', t: 'Abs', b: 'R', csvT: 'Ec', csvC: 'Ec_cal' },
  { k: 'ph', n: 'pH', t: 'Abs', b: 'R', csvT: 'Ph', csvC: 'Ph_cal' },
];

function parseRgbTriplet_(val) {
  if (!val) return { r: 0, g: 0, b: 0 };
  var parts = String(val).split(',');
  return {
    r: Number(parts[0]) || 0,
    g: Number(parts[1]) || 0,
    b: Number(parts[2]) || 0
  };
}

function pickBand_(triplet, band) {
  if (band === 'R') return triplet.r;
  if (band === 'G') return triplet.g;
  if (band === 'B') return triplet.b;
  return 0;
}

// Reconstruct frontend-like raw object from a RGB_Data row
function buildRawFromRgbRow_(rowObj) {
  var raw = {};
  STV_COLS_.forEach(function (spec) {
    raw[spec.k] = {};
    if (spec.t === 'Val') {
      // Val: treat csvT as numeric test value, no control needed
      raw[spec.k].t = Number(rowObj[spec.csvT]) || 0;
      raw[spec.k].c = 0;
    } else {
      // Abs: csvT and csvC are "R,G,B" triplets; pick band per spec.b
      var tTrip = parseRgbTriplet_(rowObj[spec.csvT]);
      var cTrip = parseRgbTriplet_(rowObj[spec.csvC]);
      raw[spec.k].t = pickBand_(tTrip, spec.b);
      raw[spec.k].c = pickBand_(cTrip, spec.b);
    }
  });
  return raw;
}

// Backend calcMetric equivalent
function calcMetricServer_(raw, key) {
  if (!raw || !raw[key]) return 0;

  // Special: pH/EC are direct from R band
  if (key === 'ph' || key === 'ec') return (Number(raw[key].t) || 0) / 100;

  var cf = STV_COLS_.find(c => c.k === key);
  if (!cf) return 0;

  var t = raw[key].t;
  var c = raw[key].c;
  if (cf.t === 'Val') return (Number(t) || 0) / 100;
  if (c === 0) return 0;
  return 1 - (t / c);
}



// Backend getSTV equivalent
function getSTVServer_(raw, key, stvMap) {
  var val = calcMetricServer_(raw, key);
  var eq = stvMap[key] || { a: 1, b: 0, df1: 1, df2: 1, df3: 1, df4: 1 };
  return ((val * eq.a) + eq.b) * eq.df1 * eq.df2 * eq.df3 * eq.df4;
}





function overrideSTVForAllTests() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  ensureSoilTestResultsSheet_();

  // --- Batch settings ---
  const CURSOR_KEY = 'STV_OVERRIDE_CURSOR';
  const BATCH_SIZE = 400;
  const SAFE_MS = 25 * 1000;
  const SHOULD_AUTO_CONTINUE = true;
  const HANDLER = 'overrideSTVForAllTests';

  const t0 = Date.now();

  // Source of truth for STV_Run_ID + saved timestamp
  const runMeta = ensureSTVRunMetaExists_();

  let stvVersion = (runMeta && runMeta.stvVersion) ? runMeta.stvVersion : getCurrentSTVVersion_();
  if (!stvVersion) {
    stvVersion = new Date().toISOString();
    setCurrentSTVVersion_(stvVersion);
  }

  const stvSavedAt = (runMeta && runMeta.stvSavedAt) ? runMeta.stvSavedAt : '';
  const stvRunId = (runMeta && runMeta.stvRunId) ? runMeta.stvRunId : '';

  // Load STV equations keyed by parameter
  const stvRows = getDataByHeaders(ss, 'STV', ['Parameter', 'a', 'b', 'df1', 'df2', 'df3', 'df4']);
  const stvMap = {};
  stvRows.forEach(function (r) {
    const key = String(r[0]);
    stvMap[key] = { a: r[1], b: r[2], df1: r[3], df2: r[4], df3: r[5], df4: r[6] };
  });

  const rgbSheet = ss.getSheetByName('RGB_Data');
  if (!rgbSheet || rgbSheet.getLastRow() < 2) return 'No RGB data found';

  const rgbData = rgbSheet.getDataRange().getValues();
  const headers = rgbData[0].map(h => String(h).trim());

  const idxTestId = headers.indexOf('test_id');
  if (idxTestId === -1) throw new Error('test_id column missing in RGB_Data');

  const idxDid = headers.indexOf('device_id');
  const idxDate = headers.indexOf('date');
  const idxClient = headers.indexOf('ClientID'); // fallback

  // --- Resume cursor ---
  const props = PropertiesService.getScriptProperties();
  let startIdx = Number(props.getProperty(CURSOR_KEY) || 1);
  if (startIdx < 1) startIdx = 1;

  const endIdx = Math.min(startIdx + BATCH_SIZE, rgbData.length);

  let processed = 0;
  let skippedNoTestId = 0;

  for (let r = startIdx; r < endIdx; r++) {
    if (Date.now() - t0 > (6 * 60 * 1000 - SAFE_MS)) break;

    const row = rgbData[r];
    const testId = row[idxTestId];
    if (!testId) { skippedNoTestId++; continue; }

    const did = (idxDid !== -1 && row[idxDid]) ? String(row[idxDid]) : '';

    // Read + parse date robustly
    const rgbDateRaw = (idxDate !== -1) ? row[idxDate] : '';
    const testDateObj = parseToDateObject_(rgbDateRaw); // must return Date or ''

    const rowObj = {};
    headers.forEach(function (h, i) { rowObj[h] = row[i]; });

    const raw = buildRawFromRgbRow_(rowObj);

    const phVal = calcMetricServer_(raw, 'ph');
    const ecVal = calcMetricServer_(raw, 'ec');
    const ocVal = getSTVServer_(raw, 'oc', stvMap);
    const nVal = getSTVServer_(raw, 'ammonium', stvMap) + getSTVServer_(raw, 'nitrate', stvMap);
    const pVal = getSTVServer_(raw, 'phosphorus', stvMap);
    const kVal = getSTVServer_(raw, 'potassium', stvMap);
    const sVal = getSTVServer_(raw, 'sulphur', stvMap);
    const cuVal = getSTVServer_(raw, 'copper', stvMap);
    const znVal = getSTVServer_(raw, 'zinccopper', stvMap) - cuVal;
    const feVal = getSTVServer_(raw, 'iron', stvMap);
    const mnVal = getSTVServer_(raw, 'manganese', stvMap);
    const bVal = getSTVServer_(raw, 'boron', stvMap);

    const clientId = (idxClient !== -1 && row[idxClient]) ? String(row[idxClient]) : 'Default';

    const soilRow = {
      Test_ID: String(testId),
      Device_ID: did,
      ClientID: clientId,
      Farm_ID: '',
      Date: testDateObj || '',    // ALWAYS Date object (or blank)
      Crop: '',

      pH: toSig2_(phVal),
      EC: toSig2_(ecVal),
      OC: toSig2_(ocVal),
      Avail_N: toSig2_(nVal),
      Avail_P: toSig2_(pVal),
      Avail_K: toSig2_(kVal),
      Avail_S: toSig2_(sVal),
      Zn: toSig2_(znVal),
      Fe: toSig2_(feVal),
      Mn: toSig2_(mnVal),
      Cu: toSig2_(cuVal),
      B: toSig2_(bVal),

      STV_Version: stvVersion,
      STV_Updated_On: stvSavedAt || '',
      STV_Run_ID: stvRunId || ''
    };

    upsertSoilTestResult_(soilRow);
    processed++;
  }

  // IMPORTANT: during override, continuously clean any old text dates and enforce format
  _cleanAndFormatSoilResultsDateColumn_();

  // --- Save next cursor ---
  const nextIdx = Math.min(endIdx, rgbData.length);
  props.setProperty(CURSOR_KEY, String(nextIdx));

  // --- Finish? ---
  if (nextIdx >= rgbData.length) {
    props.deleteProperty(CURSOR_KEY);
    _deleteContinuationTriggers_(HANDLER);
    return `Done. Processed=${processed}, skippedNoTestId=${skippedNoTestId}.`;
  }

  // --- Continue automatically (optional) ---
  if (SHOULD_AUTO_CONTINUE) {
    _deleteContinuationTriggers_(HANDLER);
    ScriptApp.newTrigger(HANDLER).timeBased().after(15 * 1000).create();
  }

  return `Batch complete. startIdx=${startIdx}, nextIdx=${nextIdx}, processed=${processed}, skippedNoTestId=${skippedNoTestId}.`;
}



function parseToDateObject_(v) {
  if (v === null || v === undefined || v === '') return '';

  // Already a Date object
  if (v instanceof Date && !isNaN(v.getTime())) return v;

  // Google Sheets serial number
  if (typeof v === 'number' && isFinite(v)) {
    const d = new Date(Math.round((v - 25569) * 86400 * 1000));
    return isNaN(d.getTime()) ? '' : d;
  }

  const s = String(v).trim();

  // 1) yyyy-mm-dd or yyyy/mm/dd (ISO-style)
  let m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
  if (m) {
    return new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
  }

  // 2) m/d/yyyy (US style with slashes only)
  m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (m) {
    return new Date(Number(m[3]), Number(m[1]) - 1, Number(m[2]));
  }

  // 3) dd-mm-yyyy (dashes only, European/Indian style)
  m = s.match(/^(\d{1,2})-(\d{1,2})-(\d{4})$/);
  if (m) {
    return new Date(Number(m[3]), Number(m[2]) - 1, Number(m[1]));
  }

  return '';
}



function setSoilResultsDateColumnFormat_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('SoilTest_Results');
  if (!sh) return;

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h).trim());
  const idx = headers.indexOf('Date');
  if (idx === -1) return;

  // Apply display format yyyy/mm/dd
  const rng = sh.getRange(2, idx + 1, Math.max(1, sh.getLastRow() - 1), 1);
  rng.setNumberFormat('yyyy/MM/dd');
}



function setSoilResultsDateFormat_() {
  const sh = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('SoilTest_Results');
  if (!sh) return;
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(String);
  const idx = headers.indexOf('Date');
  if (idx === -1) return;
  sh.getRange(2, idx + 1, Math.max(1, sh.getMaxRows() - 1), 1).setNumberFormat('@STRING@');
}


// prevent trigger pile-up
function _deleteContinuationTriggers_(handlerName) {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction && t.getHandlerFunction() === handlerName) {
      ScriptApp.deleteTrigger(t);
    }
  });
}






function saveQCCriteria(d) { saveToSheet_('QC_Criteria', d.map(o => [o.batch, o.p, o.min, o.max, o.mean]), ['QC_Batch_ID', 'Parameter', 'QC_Abs_min', 'QC_Abs_max', 'QC_Abs_mean']); }

function ensureSoilTestResultsSheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName('SoilTest_Results');

  const headers = [
    'Test_ID', 'Device_ID', 'ClientID', 'Farm_ID', 'Date', 'Crop',
    'pH', 'EC', 'OC', 'Avail_N', 'Avail_P', 'Avail_K', 'Avail_S',
    'Zn', 'Fe', 'Mn', 'Cu', 'B',
    'STV_Run_ID',        // NEW (keep it here)
    'STV_Updated_On',
    'STV_Version'
  ];

  if (!sh) {
    sh = ss.insertSheet('SoilTest_Results');
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sh;
  }

  const lastCol = Math.max(1, sh.getLastColumn());
  const existing = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(h => String(h).trim());

  // If header row is empty, just set it.
  if (!existing.filter(Boolean).length) {
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sh;
  }

  // Append any missing headers; do not reorder old columns (safe) and do not clear.
  const existingSet = {};
  existing.forEach(h => existingSet[h] = true);

  headers.forEach(h => {
    if (!existingSet[h]) {
      sh.getRange(1, sh.getLastColumn() + 1).setValue(h);
      existingSet[h] = true;
    }
  });

  return sh;
}



function setCurrentSTVVersion_(version) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName('Meta');
  if (!sh) sh = ss.insertSheet('Meta');
  const data = sh.getDataRange().getValues();
  let rowIndex = 0;
  for (let r = 0; r < data.length; r++) {
    if (String(data[r][0]) === 'STV_Version') { rowIndex = r + 1; break; }
  }
  if (rowIndex === 0) rowIndex = sh.getLastRow() + 1;
  sh.getRange(rowIndex, 1, 1, 2).setValues([['STV_Version', version]]);
}

function getCurrentSTVVersion_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('Meta');
  if (!sh || sh.getLastRow() === 0) return '';
  const data = sh.getDataRange().getValues();
  for (let r = 0; r < data.length; r++) {
    if (String(data[r][0]) === 'STV_Version') return String(data[r][1] || '');
  }
  return '';
}

function upsertSoilTestResult_(rowObj) {
  const sh = ensureSoilTestResultsSheet_();
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(String);
  const data = sh.getDataRange().getValues();
  let targetRow = 0;
  for (let r = 1; r < data.length; r++) {
    if (String(data[r][0]) === String(rowObj.Test_ID)) {
      targetRow = r + 1;
      break;
    }
  }
  if (targetRow === 0) targetRow = sh.getLastRow() + 1;
  const outRow = headers.map(h => rowObj[h] !== undefined ? rowObj[h] : '');
  sh.getRange(targetRow, 1, 1, outRow.length).setValues([outRow]);
}

function saveBlanks(d) { saveToSheet_('Blanks', d.map(o => [o.p, o.val]), ['Parameter', 'Blank Value']); }
function saveDeviceRegistry(d) { saveToSheet_('Device_Registry', d, ['Client', 'Company', 'PAN', 'GSTIN', 'Address', 'Device_ID', 'SIM', 'Aadhaar', 'Mobile', 'MO_Name', 'Installation_Date', 'Place', 'LatLon', 'PIN_code', 'Block', 'District', 'State', 'ProdBatch_ID']); }

function saveServiceTicketWithFile(data) {
  let fileUrl = "";
  if (data.fileData && data.fileName && data.deviceId) {
    try { fileUrl = uploadToDrive(data.fileData, data.fileName, data.deviceId); }
    catch (e) { fileUrl = "Upload Error: " + e.message; }
  }
  data.fileUrl = fileUrl;
  delete data.fileData;
  return saveServiceHistory(data);
}

function uploadToDrive(base64Data, fileName, deviceId) {
  const root = DriveApp.getRootFolder();
  let mainFolder;
  const mainIters = root.getFoldersByName("Insoil Tool");
  if (mainIters.hasNext()) mainFolder = mainIters.next(); else mainFolder = root.createFolder("Insoil Tool");
  let deviceFolder;
  const devIters = mainFolder.getFoldersByName(String(deviceId));
  if (devIters.hasNext()) deviceFolder = devIters.next(); else deviceFolder = mainFolder.createFolder(String(deviceId));
  const encoded = base64Data.split(',')[1] || base64Data;
  const blob = Utilities.newBlob(Utilities.base64Decode(encoded), MimeType.PDF, fileName);
  return deviceFolder.createFile(blob).getUrl();
}

function getServiceHistoryList(deviceId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Service_History');
  if (!sheet || sheet.getLastRow() < 2) return [];
  const data = sheet.getDataRange().getValues();
  const history = [];
  const norm = (val) => String(val ?? '').trim();
  const normDigits = (val) => norm(val).replace(/\D/g, '');
  const target = norm(deviceId);
  const targetDigits = normDigits(deviceId);
  for (let i = 1; i < data.length; i++) {
    const rowId = norm(data[i][1]);
    const rowDigits = normDigits(data[i][1]);
    const isMatch = rowId === target || (targetDigits && rowDigits === targetDigits);
    if (isMatch) {
      history.push({ ticket: data[i][0], date: formatDate_(data[i][2]), status: data[i][3], summary: data[i][5], fileUrl: data[i][6], fullData: data[i][7] });
    }
  }
  return history.reverse();
}

function generateServicePdf(payload) {
  let data = payload;
  if (typeof payload === 'string') {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Service_History');
    const rows = sheet.getDataRange().getValues();
    const found = rows.find(r => String(r[0]) === payload);
    if (!found) throw new Error("Ticket not found");
    data = JSON.parse(found[7]);
  }

  const html = `
    <html>
    <head><style>
      body { font-family: sans-serif; padding: 20px; color: #333; }
      h1 { color: #2c3e50; border-bottom: 2px solid #0078d4; padding-bottom: 10px; }
      
      /* Meta Data Box */
      .meta-grid { 
          display: grid; 
          grid-template-columns: 1fr 1fr; 
          gap: 10px; 
          background: #f8f9fa; 
          padding: 15px; 
          border-radius: 4px; 
          margin-bottom: 20px; 
          border: 1px solid #ddd;
      }
      .meta-item { margin-bottom: 5px; }
      .meta-label { font-weight: bold; color: #555; }
      
      /* TABLE STYLES - FIXED FOR PDF VISIBILITY */
      table { 
          width: 100%; 
          border-collapse: collapse; 
          margin-top: 20px; 
          font-size: 0.9rem; 
      }
      
      th { 
          background-color: #e2e8f0; /* Light Gray Background */
          color: #000000;            /* Black Text (High Contrast) */
          font-weight: bold; 
          padding: 10px; 
          text-align: left; 
          border: 1px solid #999;    /* Strong Border */
      }
      
      td { 
          border: 1px solid #ccc;    /* Standard Border */
          padding: 8px; 
          color: #333;
      }
      
      tr:nth-child(even) { background-color: #f9f9f9; }

      .footer { margin-top: 30px; font-size: 0.8rem; color: #888; border-top: 1px solid #eee; padding-top: 10px; }
    </style></head>
    <body>
      <h1>Service Report: ${data.ticketId}</h1>
      <div class="meta-grid">
        <div class="meta-item"><span class="meta-label">Device ID:</span> ${data.deviceId}</div>
        <div class="meta-item"><span class="meta-label">Owner:</span> ${data.owner}</div>
        <div class="meta-item"><span class="meta-label">Date:</span> ${data.date || new Date().toDateString()}</div>
        <div class="meta-item"><span class="meta-label">Status:</span> ${data.status}</div>
        <div class="meta-item"><span class="meta-label">Technician:</span> ${data.empId || 'N/A'}</div>
      </div>
      <div style="margin-bottom: 16px;">
        <div style="font-weight:700; margin-bottom:4px;">Customer Statement</div>
        <div style="border:1px solid #ddd; padding:10px; border-radius:4px; background:#fafafa;">
          ${data.cutometerStatement ? data.cutometerStatement : 'N/A'}
        </div>
      </div>
      
      <h3>Action Log</h3>
      <table>
        <thead>
            <tr>
                <th>Section</th>
                <th>Component</th>
                <th>Sub-Component</th>
                <th>Action</th>
                <th>Sub-Action</th>
                <th>Unit</th>
                <th>Cost (INR/unit)</th>
            </tr>
        </thead>
        <tbody>
          ${data.actions.map(a => `
            <tr>
              <td>${a.section}</td>
              <td>${a.btn}</td>
              <td>${a.sub}</td>
              <td>${a.act}</td>
              <td>${a.subAct || '-'}</td>
              <td>${a.unit || '-'}</td>
              <td>${a.cost != null ? a.cost : '-'}</td>
            </tr>`).join('')}
          ${data.actions.length === 0 ? '<tr><td colspan="7" style="text-align:center; padding:20px;">No actions recorded.</td></tr>' : ''}
        </tbody>
      </table>
      <h3>Cost Summary</h3>
      <table>
        <thead>
            <tr>
              <th>Item</th>
              <th>Unit</th>
              <th>Cost (INR/unit)</th>
            </tr>
        </thead>
        <tbody>
          ${(data.costSummary && data.costSummary.items ? data.costSummary.items : data.actions).map(a => `
            <tr>
              <td>${a.btn} / ${a.sub} / ${a.subAct || a.act}</td>
              <td>${a.unit || '-'}</td>
              <td>${a.cost != null ? a.cost : '-'}</td>
            </tr>`).join('')}
          ${(data.costSummary?.items?.length || data.actions.length) ? '' : '<tr><td colspan="3" style="text-align:center; padding:20px;">No items selected.</td></tr>'}
        </tbody>
      </table>
      <div style="margin-top:8px; font-weight:700;">Total Cost: ₹${data.costSummary?.total ?? data.actions.reduce((sum, a) => sum + (Number(a.cost) || 0), 0)}</div>
      <div class="footer">Generated by Insoil Tool</div>
    </body>
    </html>
  `;
  const blob = Utilities.newBlob(html, MimeType.HTML).getAs(MimeType.PDF);
  blob.setName(`Service_${data.ticketId}.pdf`);
  return { base64: Utilities.base64Encode(blob.getBytes()), filename: blob.getName() };
}

// =============================
// MODULE 5: AUTH / ADMIN / MISC
// =============================
// ... User Auth & Admin functions (Keep existing) ...
function checkLogin(username, password) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName('Users');
  if (!sheet && username === 'admin' && password === 'admin123') return { success: true, role: 'Admin', user: 'SuperAdmin', modules: ['all'] };
  if (!sheet) return { success: false, msg: "System not initialized." };
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if ((String(data[i][0]).trim() === username || String(data[i][1]).trim() === username) && String(data[i][2]).trim() === password) {
      let modules = null;
      if (data[i].length > 5 && data[i][5]) modules = String(data[i][5]).split(',').map(s => s.trim());
      return { success: true, role: data[i][3], user: String(data[i][0]), modules: modules };
    }
  }
  return { success: false, msg: "Invalid credentials" };
}

function adminCreateUser(data) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName('Users');
  if (!sheet) { sheet = ss.insertSheet('Users'); sheet.appendRow(['Employee_ID', 'Email', 'Password', 'Role', 'Created_Date', 'Access_Modules']); }
  sheet.appendRow([data.empId, data.email, data.password, data.role, new Date(), data.modules ? data.modules.join(',') : ""]);
  appendAdminAudit_('create_user', data.empId, `role=${data.role}`);
  return "User created.";
}

function getAllUsers() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Users');
  if (!sheet) return [];
  const data = sheet.getDataRange().getValues();
  const users = [];
  for (let i = 1; i < data.length; i++) users.push({ empId: String(data[i][0]), role: String(data[i][3]), modules: (data[i][5]) ? String(data[i][5]).split(',') : [] });
  return users;
}

function adminUpdateUserPermissions(empId, modules) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Users');
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]) === empId) {
      sheet.getRange(i + 1, 6).setValue(modules.join(','));
      appendAdminAudit_('update_permissions', empId, `modules=${modules.join(',')}`);
      return "Permissions updated.";
    }
  }
  throw new Error("User not found.");
}

function adminResetUserPassword(empId, newPassword) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Users');
  if (!sheet) throw new Error("Users sheet not found.");

  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]) === empId) {
      sheet.getRange(i + 1, 3).setValue(newPassword);
      appendAdminAudit_('reset_password', empId, '');
      return "Password reset.";
    }
  }
  throw new Error("User not found.");
}

function appendAdminAudit_(action, target, details) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName('Admin_Audit_Log');
  if (!sheet) {
    sheet = ss.insertSheet('Admin_Audit_Log');
    sheet.appendRow(['Timestamp', 'Action', 'Actor', 'Target', 'Details']);
  }
  const actor = Session.getActiveUser().getEmail() || 'unknown';
  sheet.appendRow([new Date(), action, actor, target || '', details || '']);
}

function appendCSVRowsToRGBData_(rows) {
  throw new Error(
    'appendCSVRowsToRGBData_ is deprecated. Use syncMoveDataToRGB instead.'
  );
}


function saveManualEntry(item, type) { return "Manual Entry Saved"; }


function ensureNutrientConfigSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const defs = [
    {
      name: 'SoilFertilityRatings',
      headers: [
        'ClientID', 'RatingSchemeID', 'Parameter', 'ClassName', 'ClassOrder',
        'MinValue', 'MaxValue', 'Unit', 'Notes'
      ]
    },
    {
      name: 'NutrientCrops',
      headers: [
        'ClientID', 'CropID', 'CropName', 'Category', 'SeasonType',
        'DefaultTargetYield', 'YieldUnit', 'RootDepthClass', 'ActiveFlag', 'Notes'
      ]
    },
    {
      name: 'NutrientStages',
      headers: [
        'ClientID', 'CropID', 'StageID', 'StageName', 'SequenceNo',
        'StartDayFromSowing', 'EndDayFromSowing',
        'ForTreeYearFrom', 'ForTreeYearTo', 'Notes'
      ]
    },
    {
      name: 'NutrientMethods',
      headers: [
        'ClientID', 'MethodID', 'MethodName', 'Description', 'ActiveFlag'
      ]
    },
    {
      name: 'NutrientTargets',
      headers: [
        'ClientID', 'CropID', 'StageID', 'MethodID', 'RatingSchemeID',
        'Parameter', 'SoilClass',
        'BaseDosePerHa', 'DosePerTonneYield',
        'MaxDosePerHa', 'MinDosePerHa', 'Notes'
      ]
    },
    {
      name: 'NutrientSources',
      headers: [
        'ClientID', 'SourceID', 'SourceName', 'Type',
        'GradeN', 'GradeP2O5', 'GradeK2O',
        'GradeS', 'GradeZn', 'GradeB',
        'SuitableMethods', 'DefaultUseStage',
        'UnitBasis', 'UnitSize', 'PricePerUnit', 'Currency',
        'Notes'
      ]
    },
    {
      name: 'NutrientSourceMixes',
      headers: [
        'ClientID', 'CropID', 'StageID', 'MethodID', 'MixID',
        'PreferredSourceIDs',
        'MaxUreaPerAppl', 'MaxP2O5PerAppl', 'MaxK2OPerAppl',
        'OrganicFraction', 'Notes'
      ]
    },
    {
      name: 'ConfigLegend',
      headers: [
        'TableName', 'ColumnName', 'DataType',
        'AllowedValuesFormat', 'Description', 'ExampleValue'
      ]
    },
    {
      name: 'NutrientSTCR',
      headers: [
        'ClientID', 'CropID', 'RatingSchemeID', 'Nutrient',
        'EquationType', 'CoeffYield', 'CoeffSoil', 'CoeffOrganic',
        'MinDosePerHa', 'MaxDosePerHa',
        'YieldUnit', 'SoilUnit', 'Notes'
      ]
    },
    {
      name: 'NutrientDoseEngine',
      headers: [
        'ClientID', 'CropID', 'Nutrient', 'RatingSchemeID',
        'DoseEngine' // CLASS / STCR / CRITICAL
      ]
    }
  ];

  defs.forEach(function (def) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sh = ss.getSheetByName(def.name);
    if (!sh) {
      sh = ss.insertSheet(def.name);
      if (def.headers && def.headers.length) {
        sh.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
      }
    }
  });
}


function debugNutrientConfig() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  Logger.log('--- SoilFertilityRatings ---');
  const fert = getDataByHeaders(ss, 'SoilFertilityRatings', [
    'ClientID', 'RatingSchemeID', 'Parameter', 'ClassName', 'ClassOrder',
    'MinValue', 'MaxValue', 'Unit', 'Notes'
  ]) || [];
  Logger.log('Rows: ' + fert.length);

  Logger.log('--- NutrientCrops ---');
  const crops = getDataByHeaders(ss, 'NutrientCrops', [
    'ClientID', 'CropID', 'CropName', 'Category', 'SeasonType',
    'DefaultTargetYield', 'YieldUnit', 'RootDepthClass', 'ActiveFlag', 'Notes'
  ]) || [];
  Logger.log('Rows: ' + crops.length);

  Logger.log('--- NutrientMethods ---');
  const methods = getDataByHeaders(ss, 'NutrientMethods', [
    'ClientID', 'MethodID', 'MethodName', 'Description', 'ActiveFlag'
  ]) || [];
  Logger.log('Rows: ' + methods.length);
}


function getNutrientSourcesMap_(ss, clientId) {
  const rows = getDataByHeaders(ss, 'NutrientSources', [
    'ClientID', 'SourceID', 'SourceName', 'Type',
    'GradeN', 'GradeP2O5', 'GradeK2O', 'GradeS', 'GradeZn', 'GradeB',
    'SuitableMethods', 'DefaultUseStage',
    'UnitBasis', 'UnitSize', 'PricePerUnit', 'Currency', 'Notes'
  ]) || [];

  const map = { N: [], P2O5: [], K2O: [], S: [], Zn: [], B: [] };

  rows.forEach(function (r) {
    if (String(r[0]) !== clientId && String(r[0]) !== 'Default') return;

    function pushIf(percent, key) {
      if (percent && percent > 0) {
        map[key].push({
          sourceId: r[1],
          name: r[2],
          type: r[3],
          N: r[4] || 0,
          P2O5: r[5] || 0,
          K2O: r[6] || 0,
          S: r[7] || 0,
          Zn: r[8] || 0,
          B: r[9] || 0,
          suitableMethods: String(r[10] || ''),
          defaultStage: String(r[11] || ''),
          unitBasis: String(r[12] || 'bag'),
          unitSize: Number(r[13]) || 1,
          pricePerUnit: Number(r[14]) || 0,
          currency: String(r[15] || 'INR'),
          notes: r[16] || ''
        });
      }
    }

    pushIf(r[4], 'N');
    pushIf(r[5], 'P2O5');
    pushIf(r[6], 'K2O');
    pushIf(r[7], 'S');
    pushIf(r[8], 'Zn');
    pushIf(r[9], 'B');
  });

  return map;
}

function getNutrientSources_(clientId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rows = getDataByHeaders(ss, 'NutrientSources', [
    'ClientID',
    'SourceID',
    'SourceName',
    'Type',
    'GradeN',
    'GradeP2O5',
    'GradeK2O',
    'GradeS',
    'GradeZn',
    'GradeB',
    'SuitableMethods',
    'DefaultUseStage',
    'UnitBasis',
    'UnitSize',
    'PricePerUnit',
    'Currency',
    'Notes'
  ]) || [];

  const cid = clientId || 'Default';
  const list = [];

  rows.forEach(function (r) {
    const rowClient = String(r[0] || '').trim();
    if (rowClient !== cid && rowClient !== 'Default') return;

    list.push({
      clientId: rowClient,
      sourceId: String(r[1] || '').trim(),
      name: String(r[2] || '').trim(),
      type: String(r[3] || '').trim(),   // Straight / Complex / etc.
      N: Number(r[4]) || 0,
      P2O5: Number(r[5]) || 0,
      K2O: Number(r[6]) || 0,
      S: Number(r[7]) || 0,
      Zn: Number(r[8]) || 0,
      B: Number(r[9]) || 0,
      suitableMethods: String(r[10] || ''),
      defaultStage: String(r[11] || ''),  // BASAL / VEG / TILLERING / FLOWERING
      unitBasis: String(r[12] || 'bag'),
      unitSize: Number(r[13]) || 1,
      pricePerUnit: Number(r[14]) || 0,
      currency: String(r[15] || 'INR'),
      notes: String(r[16] || '')
    });
  });

  return list;
}

function buildNutrientSourceSelectors_(clientId) {
  const list = getNutrientSources_(clientId);
  const selectors = {
    primaryN: null,
    primaryK2O: null,
    pByStage: {},   // e.g. pByStage['BASAL'] = [DAP, ...]
    nByStage: {},   // e.g. nByStage['BASAL'] = [Urea, ...]
    kByStage: {}    // e.g. kByStage['BASAL'] = [MOP, ...]
  };

  list.forEach(function (s) {
    const stage = (s.defaultStage || '').toUpperCase(); // BASAL / VEG / TILLERING / FLOWERING

    // Primary straight N source
    if (s.N > 0 && s.type === 'Straight') {
      if (!selectors.primaryN) selectors.primaryN = s;
      if (stage) {
        if (!selectors.nByStage[stage]) selectors.nByStage[stage] = [];
        selectors.nByStage[stage].push(s);
      }
    }

    // Primary straight K source
    if (s.K2O > 0 && s.type === 'Straight') {
      if (!selectors.primaryK2O) selectors.primaryK2O = s;
      if (stage) {
        if (!selectors.kByStage[stage]) selectors.kByStage[stage] = [];
        selectors.kByStage[stage].push(s);
      }
    }

    // P complexes by stage
    if (s.P2O5 > 0 && s.type === 'Complex') {
      if (!selectors.pByStage[stage]) selectors.pByStage[stage] = [];
      selectors.pByStage[stage].push(s);
    }
  });

  return selectors;
}



function debugNutrientSources(clientId) {
  const srcs = getNutrientSources_(clientId || 'Default');
  Logger.log('NutrientSources for ' + (clientId || 'Default') + ': ' + srcs.length);
  srcs.forEach(function (s) {
    Logger.log(
      s.name + ' N:' + s.N + ' P2O5:' + s.P2O5 +
      ' K2O:' + s.K2O + ' stage:' + s.defaultStage +
      ' unit:' + s.unitSize + ' price:' + s.pricePerUnit
    );
  });
}

function debugNutrientSelectors(clientId) {
  const sel = buildNutrientSourceSelectors_(clientId || 'Default');
  Logger.log('Primary N: ' + (sel.primaryN ? sel.primaryN.name : 'none'));
  Logger.log('Primary K2O: ' + (sel.primaryK2O ? sel.primaryK2O.name : 'none'));

  Object.keys(sel.pByStage).forEach(function (st) {
    const names = sel.pByStage[st].map(function (s) { return s.name; }).join(', ');
    Logger.log('P sources for stage ' + st + ': ' + names);
  });
}


function debugBuildStagesOnce() {
  const fakeSummary = [
    { nutrient: 'N', baseDose: 120, doseMultiplier: 1 },
    { nutrient: 'P', baseDose: 60, doseMultiplier: 1 },
    { nutrient: 'K', baseDose: 120, doseMultiplier: 1 }
  ];

  const stages = buildGeneralStages_(fakeSummary, 'WHEAT', 'Default', 'GEN', 'STD', 0);
  Logger.log('debugBuildStagesOnce stages.length=' + stages.length);
  Logger.log('Sample stages[0..4]: ' + JSON.stringify(stages.slice(0, 5)));
}


//---------------------------------------------------------------------------------------------
//----------------------NEW CODE BLOCK WITH NUTRIENTMASTER TABLE -------------------------------
//---------------------------------------------------------------------------------------------




/**
 * Generic helper to read a sheet as {headers, rows, getCol(name)}.
 */
function getSheetDataByHeader_(sheetName) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(sheetName);
  if (!sh) throw new Error('Sheet not found: ' + sheetName);

  const values = sh.getDataRange().getValues();
  if (values.length < 2) return { headers: [], rows: [], getCol: () => -1 };

  const headers = values.shift();
  return {
    headers,
    rows: values,
    getCol(name) {
      const idx = headers.indexOf(name);
      if (idx === -1) {
        throw new Error('Column not found in ' + sheetName + ': ' + name);
      }
      return idx;
    }
  };
}



/**
 * Build a map { Parameter: Rating } using SoilFertilityRatings.
 * soilValuesByParam: e.g. { N: 220, P2O5: 14, K2O: 150 }
 */
function buildRatingsByParam_(clientID, ratingSchemeID, soilValuesByParam) {
  const ratings = getSheetDataByHeader_('SoilFertilityRatings');

  const cClient = ratings.getCol('ClientID');
  const cScheme = ratings.getCol('RatingSchemeID');
  const cParam = ratings.getCol('Parameter');
  const cClass = ratings.getCol('ClassName');
  const cMin = ratings.getCol('MinValue');
  const cMax = ratings.getCol('MaxValue');
  const cMult = ratings.getCol('DoseMultiplier');

  const out = {}; // { N: { rating: 'Low', multiplier: 1.25 }, ... }

  Object.keys(soilValuesByParam).forEach(param => {
    const value = Number(soilValuesByParam[param]);
    if (isNaN(value)) return;

    const matchingRows = ratings.rows.filter(r =>
      String(r[cClient]) === String(clientID) &&
      String(r[cScheme]) === String(ratingSchemeID) &&
      String(r[cParam]) === String(param)
    );

    for (const row of matchingRows) {
      const min = Number(row[cMin]);
      const max = Number(row[cMax]);
      if ((isNaN(min) || value >= min) && (isNaN(max) || value <= max)) {
        out[param] = {
          rating: String(row[cClass]),
          multiplier: Number(row[cMult]) || 0
        };
        break;
      }
    }
  });

  return out;
}




/**
 * Get which engine to use for a given crop + nutrient + scheme.
 * Returns 'RDF' by default if nothing is configured.
 */
function getDoseEngineFor_(clientID, cropID, nutrient, ratingSchemeID) {
  const de = getSheetDataByHeader_('NutrientDoseEngine');

  const cClient = de.getCol('ClientID');
  const cCrop = de.getCol('CropID');
  const cNut = de.getCol('Nutrient');
  const cScheme = de.getCol('RatingSchemeID');
  const cEng = de.getCol('DoseEngine');

  const row = de.rows.find(r =>
    String(r[cClient]) === String(clientID) &&
    String(r[cCrop]) === String(cropID) &&
    String(r[cNut]) === String(nutrient) &&
    String(r[cScheme]) === String(ratingSchemeID)
  );

  return row ? String(row[cEng] || '').toUpperCase() : 'RDF';
}



/**
 * Compute dose using LMH-based RDF from NutrientMaster.
 *
 * NutrientMaster headers:
 * ClientID | CropID | StageID | MethodID | RatingSchemeID | Nutrient
 * | RDF_kg_ha | DosePerTonneYield | MaxDosePerHa | MinDosePerHa | Notes
 *
 * ratingInfo = { rating: 'Low'|'Medium'|..., multiplier: number }
 */
function computeDoseFromRDF_(clientID, cropID, stageID, methodID, ratingSchemeID, nutrient, ratingInfo, targetYield) {
  const master = getSheetDataByHeader_('NutrientMaster');

  const cClient = master.getCol('ClientID');
  const cCrop = master.getCol('CropID');
  const cStage = master.getCol('StageID');
  const cMethod = master.getCol('MethodID');
  const cScheme = master.getCol('RatingSchemeID');
  const cNutrient = master.getCol('Nutrient');
  const cRDF = master.getCol('RDF_kg_ha');
  const cDosePerT = master.getCol('DosePerTonneYield');
  const cMaxDose = master.getCol('MaxDosePerHa');
  const cMinDose = master.getCol('MinDosePerHa');
  const cNotes = master.getCol('Notes');

  const row = master.rows.find(r =>
    String(r[cClient]) === String(clientID) &&
    String(r[cCrop]) === String(cropID) &&
    String(r[cStage]) === String(stageID) &&
    String(r[cMethod]) === String(methodID) &&
    String(r[cScheme]) === String(ratingSchemeID) &&
    String(r[cNutrient]) === String(nutrient)
  );
  if (!row) return null;

  const baseRDF = Number(row[cRDF]) || 0;
  const perT = Number(row[cDosePerT]) || 0;
  const maxDose = Number(row[cMaxDose]) || 0;
  const minDose = Number(row[cMinDose]) || 0;

  const mult = ratingInfo ? (ratingInfo.multiplier || 0) : 0;
  const T = Math.max(0, Number(targetYield) || 0);

  // Core RDF formula: base RDF scaled by LMH multiplier + yield increment
  let dose = baseRDF * mult + perT * T;

  if (maxDose > 0) dose = Math.min(dose, maxDose);
  if (minDose > 0) dose = Math.max(dose, minDose);

  return {
    dose_kg_ha: dose,
    rdf_kg_ha: baseRDF,
    dosePerTonneYield: perT,
    maxDosePerHa: maxDose,
    minDosePerHa: minDose,
    notes: row[cNotes] || ''
  };
}



/**
 * Compute dose using STCR equation:
 * F = CoeffYield * T - CoeffSoil * S - CoeffOrganic * O
 * where T = target yield, S = soil test, O = organic contribution.
 */
function computeDoseFromSTCR_(clientID, cropID, ratingSchemeID, nutrient, targetYield, soilTestValue, organicIndex, methodID) {
  const stcr = getSheetDataByHeader_('NutrientSTCR');

  const cClient = stcr.getCol('ClientID');
  const cCrop = stcr.getCol('CropID');
  const cScheme = stcr.getCol('RatingSchemeID');
  const cNut = stcr.getCol('Nutrient');
  const cEqType = stcr.getCol('EquationType');
  const cCy = stcr.getCol('CoeffYield');
  const cCs = stcr.getCol('CoeffSoil');
  const cCo = stcr.getCol('CoeffOrganic');
  const cMinDose = stcr.getCol('MinDosePerHa');
  const cMaxDose = stcr.getCol('MaxDosePerHa');
  const cNotes = stcr.getCol('Notes');
  const cMethod = stcr.headers.indexOf('MethodID'); // optional

  const row = stcr.rows.find(r =>
    String(r[cClient]) === String(clientID) &&
    String(r[cCrop]) === String(cropID) &&
    String(r[cScheme]) === String(ratingSchemeID) &&
    String(r[cNut]) === String(nutrient) &&
    (cMethod === -1 || String(r[cMethod] || '') === String(methodID))
  );
  if (!row) return null;

  const eqType = String(row[cEqType] || '').toUpperCase();
  const Cy = Number(row[cCy]) || 0;
  const Cs = Number(row[cCs]) || 0;
  const Co = Number(row[cCo]) || 0;
  const minDose = Number(row[cMinDose]) || 0;
  const maxDose = Number(row[cMaxDose]) || 0;

  const Y = Number(targetYield) || 0;  // T
  const S = Number(soilTestValue) || 0;  // SN / SP / SK
  const Org = Number(organicIndex) || 0;  // ON / OP / OK

  let dose = 0;

  // Linear STCR (your FN, FP2O5, FK2O equations)
  if (eqType === 'LINEAR' || !eqType) {
    dose = Cy * Y - Cs * S - Co * Org;
  } else {
    // Other types can be added later
    dose = Cy * Y - Cs * S - Co * Org;
  }

  if (maxDose > 0) dose = Math.min(dose, maxDose);
  if (minDose > 0) dose = Math.max(dose, minDose);

  return {
    dose_kg_ha: Math.max(0, dose),
    minDosePerHa: minDose,
    maxDosePerHa: maxDose,
    notes: row[cNotes] || ''
  };
}



/**
 * Main entry: compute nutrient-wise doses for a field.
 *
 * input = {
 *   clientID,
 *   cropID,
 *   stageID,
 *   methodID,        // e.g. 'RDF', 'STCR_NPK', 'STCR_IPNS'
 *   ratingSchemeID,
 *   targetYield,     // in same unit used in RDF/STCR tables
 *   soilValuesByParam: { N: 220, P2O5: 14, K2O: 150, ... },
 *   organicIndexByParam: { N: 0, P2O5: 0, K2O: 0, ... } // optional
 * }
 */
function getFinalNutrientRecommendations(input) {
  const {
    clientID,
    cropID,
    stageID,
    methodID,
    ratingSchemeID,
    targetYield,
    soilValuesByParam,
    organicIndexByParam
  } = input;

  const ratingsByParam = buildRatingsByParam_(
    clientID,
    ratingSchemeID,
    soilValuesByParam
  );

  const results = [];

  Object.keys(soilValuesByParam).forEach(nutrient => {
    const soilValue = soilValuesByParam[nutrient];
    const ratingInfo = ratingsByParam[nutrient] || { rating: '', multiplier: 0 };
    const soilRating = ratingInfo.rating;
    const organicIdx = organicIndexByParam ? organicIndexByParam[nutrient] : 0;

    const engine = getDoseEngineFor_(clientID, cropID, nutrient, ratingSchemeID);

    let doseInfo = null;

    if (engine.indexOf('STCR') === 0) {
      doseInfo = computeDoseFromSTCR_(
        clientID,
        cropID,
        ratingSchemeID,
        nutrient,
        targetYield,
        soilValue,
        organicIdx,
        methodID
      );
    } else {
      doseInfo = computeDoseFromRDF_(
        clientID,
        cropID,
        stageID,
        methodID,
        ratingSchemeID,
        nutrient,
        ratingInfo,
        targetYield
      );
    }

    if (!doseInfo) return;

    results.push({
      clientID,
      cropID,
      stageID,
      methodID,
      ratingSchemeID,
      nutrient,
      doseEngine: engine,
      soilValue,
      soilRating,
      multiplier: ratingInfo.multiplier,
      dose_kg_ha: doseInfo.dose_kg_ha,
      rdf_kg_ha: doseInfo.rdf_kg_ha || null,
      dosePerTonneYield: doseInfo.dosePerTonneYield || null,
      minDosePerHa: doseInfo.minDosePerHa || null,
      maxDosePerHa: doseInfo.maxDosePerHa || null,
      notes: doseInfo.notes || ''
    });
  });

  return results;
}



function testFinalNutrientRecommendations() {
  const input = {
    clientID: 'Default',
    cropID: 'WHEAT',
    stageID: 'BASAL',
    methodID: 'SOIL',
    ratingSchemeID: 'LMH',
    targetYield: 5,
    soilValuesByParam: {
      N: 220,
      P2O5: 14,
      K2O: 150
    },
    organicIndexByParam: {
      N: 0,
      P2O5: 0,
      K2O: 0
    }
  };

  Logger.log(JSON.stringify(input));  // add this
  const res = getFinalNutrientRecommendations(input);
  Logger.log(JSON.stringify(res, null, 2));
}

// ------------------------------
// UI wrapper: return base64 for direct download
// ------------------------------
function generateNutrientPlanPDFForUI(cfg) {
  var html = buildNutrientPlanPDF(cfg);           // returns HTML string
  var blob = Utilities.newBlob(html, 'text/html', 'plan.html'); // Blob

  // Convert HTML blob to PDF using Drive
  var pdfBlob = blob.getAs('application/pdf');   // Still a Blob

  // For returning to client as base64:
  var base64 = Utilities.base64Encode(pdfBlob.getBytes());

  return {
    success: true,
    pdfBase64: base64,
    fileName: 'Insoil_Plan_' + (cfg.cropName || 'Plan') + '.pdf'
  };
}

function generateNutrientPlanPDFForTest(testId, deviceId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  ensureSoilTestResultsSheet_();
  const sh = ss.getSheetByName('SoilTest_Results');
  ensureColumnWithDefault_(sh, 1, 'Crop', 'Wheat');
  const data = sh.getDataRange().getValues();
  if (data.length < 2) return { success: false, msg: 'SoilTest_Results has no data.' };

  const headers = data[0].map(String);
  const idxTestId = getHeaderIndex_(headers, 'Test_ID');
  const idxDeviceId = getHeaderIndex_(headers, 'Device_ID');
  if (idxTestId === -1) return { success: false, msg: 'SoilTest_Results missing Test_ID column.' };

  let rowObj = null;
  for (let r = 1; r < data.length; r++) {
    const matchTest = String(data[r][idxTestId]).trim() === String(testId).trim();
    const matchDevice = idxDeviceId === -1 || !deviceId
      ? true
      : String(data[r][idxDeviceId]).trim() === String(deviceId).trim();
    if (matchTest && matchDevice) {
      rowObj = {};
      headers.forEach((h, i) => rowObj[h] = data[r][i]);
      break;
    }
  }
  if (!rowObj) return { success: false, msg: 'Test ID not found in SoilTest_Results.' };

  const clientId = rowObj['ClientID'] || 'Default';
  let cropId = rowObj['Crop'] || rowObj['CropID'] || '';
  let cropIsDefault = false;
  let ratingSchemeId = rowObj['RatingSchemeID'] || rowObj['Rating_Scheme'] || '';
  let methodId = rowObj['MethodID'] || rowObj['Method'] || 'GEN';
  const targetYield = Number(rowObj['TargetYield'] || rowObj['Target_Yield'] || 0);

  const config = getNutrientManagerConfig(clientId) || {};
  if (!ratingSchemeId && Array.isArray(config.ratingSchemes) && config.ratingSchemes.length) {
    ratingSchemeId = config.ratingSchemes[0].id;
  }
  if (!methodId && Array.isArray(config.methods) && config.methods.length) {
    methodId = config.methods[0].id;
  }
  if (!cropId) {
    cropId = 'Rice';
    cropIsDefault = true;
  }

  const plan = getNutrientPlanForTest(
    testId,
    deviceId,
    clientId,
    ratingSchemeId,
    methodId,
    cropId,
    targetYield
  );

  if (!plan || !Array.isArray(plan.stages)) {
    return { success: false, msg: 'Failed to build nutrient plan for report.' };
  }

  const cropNameRaw = (config.crops || []).find(c => String(c.cropId) === String(cropId))?.name || cropId || 'Unknown';
  const cropName = cropIsDefault ? `${cropNameRaw} (Default)` : cropNameRaw;
  const ratingSchemeName = (config.ratingSchemes || []).find(r => String(r.id) === String(ratingSchemeId))?.label || ratingSchemeId || '';
  const methodName = (config.methods || []).find(m => String(m.id) === String(methodId))?.label || methodId || '';

  let totalN = 0, totalP = 0, totalK = 0;
  plan.stages.forEach(function (s) {
    const nut = (s.nutrient || '').toUpperCase();
    const d = Number(s.dose || 0);
    if (nut === 'N') totalN += d;
    if (nut === 'P₂O₅' || nut === 'P2O5' || nut === 'P') totalP += d;
    if (nut === 'K₂O' || nut === 'K2O' || nut === 'K') totalK += d;
  });

  const cfg = {
    clientId: clientId,
    clientName: clientId,
    ratingSchemeId: ratingSchemeId,
    ratingSchemeName: ratingSchemeName,
    testId: testId,
    deviceId: deviceId,
    cropId: cropId,
    cropName: cropName,
    methodId: methodId,
    methodName: methodName,
    targetYield: targetYield,
    nRate: totalN,
    pRate: totalP,
    kRate: totalK,
    stages: plan.stages || [],
    fertilizerMaterials: [],
    fertilizerCosts: []
  };

  return generateNutrientPlanPDFForUI(cfg);
}

function getHeaderIndex_(headers, headerName) {
  const target = String(headerName || '').toLowerCase().replace(/[\s_-]/g, '');
  for (let i = 0; i < headers.length; i++) {
    const key = String(headers[i] || '').toLowerCase().replace(/[\s_-]/g, '');
    if (key === target) return i;
  }
  return -1;
}



// ------------------------------
// Nutrient Plan: HTML → PDF
// ------------------------------
function buildNutrientPlanPDF(cfg) {
  const pageWidth = 210;  // mm
  const pageHeight = 297; // mm
  const margin = 12;

  const colors = {
    headerBg: '#2C5F2D',
    headerText: '#FFFFFF',
    accentColor: '#4CAF50',
    borderColor: '#D0D0D0',
    textPrimary: '#1F1F1F',
    textSecondary: '#555555',
    tableHeaderBg: '#E8F5E9',
    tableHeaderText: '#1B5E20',
    altRowBg: '#F5F5F5'
  };

  let html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>Nutrient Management Plan - ${cfg.cropName}</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          color: ${colors.textPrimary};
          background: white;
          line-height: 1.35;
          font-size: 9pt;
        }
        .page {
          width: 210mm;
          height: 297mm;
          page-break-after: always;
          padding: ${margin}mm;
          background: white;
          position: relative;
        }
        .page:last-child {
          page-break-after: avoid;
        }

        .header {
          background: linear-gradient(135deg, ${colors.headerBg} 0%, #1e4620 100%);
          color: ${colors.headerText};
          padding: 6mm 8mm;
          border-radius: 6px;
          margin-bottom: 8mm;
          box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
        .header h1 {
          font-size: 16pt;
          font-weight: 700;
          margin-bottom: 2mm;
        }
        .header p {
          font-size: 8pt;
          opacity: 0.95;
          margin: 1mm 0;
        }

        .section-title {
          background: ${colors.accentColor};
          color: white;
          padding: 3mm 5mm;
          margin-top: 6mm;
          margin-bottom: 4mm;
          border-radius: 3px;
          font-size: 10pt;
          font-weight: 600;
          border-left: 3px solid #1e4620;
        }
        .section-title:first-of-type {
          margin-top: 0;
        }

        .info-grid {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 4mm;
          margin-bottom: 6mm;
        }
        .info-box {
          background: ${colors.tableHeaderBg};
          padding: 3mm 4mm;
          border-radius: 3px;
          border-left: 2px solid ${colors.accentColor};
        }
        .info-box label {
          font-size: 7pt;
          color: ${colors.tableHeaderText};
          font-weight: 600;
          text-transform: uppercase;
          letter-spacing: 0.4px;
        }
        .info-box .value {
          font-size: 9pt;
          color: ${colors.textPrimary};
          margin-top: 1.5mm;
          font-weight: 500;
          word-break: break-word;
        }

        table {
          width: 100%;
          border-collapse: collapse;
          margin-bottom: 6mm;
          font-size: 8.5pt;
          background: white;
          border-radius: 3px;
          overflow: hidden;
        }
        table thead {
          background: ${colors.tableHeaderBg};
        }
        table th {
          background: ${colors.tableHeaderBg};
          color: ${colors.tableHeaderText};
          padding: 2.5mm 3.5mm;
          text-align: left;
          font-weight: 600;
          font-size: 8pt;
          text-transform: uppercase;
          letter-spacing: 0.4px;
          border-bottom: 1px solid ${colors.accentColor};
        }
        table td {
          padding: 2mm 3.5mm;
          border-bottom: 1px solid ${colors.borderColor};
          vertical-align: middle;
        }
        table tbody tr:nth-child(even) {
          background: ${colors.altRowBg};
        }
        table tbody tr:last-child td {
          border-bottom: 1px solid ${colors.accentColor};
        }

        .summary-box {
          background: linear-gradient(135deg, ${colors.tableHeaderBg} 0%, #F1F8F5 100%);
          border: 1px solid ${colors.accentColor};
          border-radius: 4px;
          padding: 5mm 6mm;
          margin: 5mm 0;
          font-size: 8.5pt;
        }
        .summary-box h4 {
          color: ${colors.tableHeaderText};
          font-size: 9pt;
          margin-bottom: 3mm;
          text-transform: uppercase;
          letter-spacing: 0.4px;
        }
        .summary-row {
          display: flex;
          justify-content: space-between;
          padding: 2mm 0;
          border-bottom: 1px solid ${colors.borderColor};
        }
        .summary-row:last-child {
          border-bottom: none;
        }
        .summary-row .label {
          font-weight: 600;
          color: ${colors.tableHeaderText};
        }
        .summary-row .value {
          color: ${colors.textPrimary};
          font-weight: 500;
        }

        .footer {
          font-size: 7.5pt;
          color: ${colors.textSecondary};
          border-top: 1px solid ${colors.borderColor};
          margin-top: 8mm;
          padding-top: 3mm;
          text-align: center;
        }

        .highlight {
          background: #FFFACD;
          font-weight: 600;
          color: ${colors.headerBg};
          padding: 0 1mm;
          border-radius: 2px;
        }

        .page-number {
          position: absolute;
          bottom: 8mm;
          right: 12mm;
          font-size: 7.5pt;
          color: ${colors.textSecondary};
        }

        .table-container {
          border-radius: 3px;
          overflow: hidden;
        }
        .table-title {
          background: ${colors.tableHeaderBg};
          padding: 3mm 4mm;
          font-size: 8.5pt;
          font-weight: 600;
          color: ${colors.tableHeaderText};
          border-bottom: 1px solid ${colors.accentColor};
        }

        @media print {
          .page { page-break-after: always; }
          .page:last-child { page-break-after: avoid; }
        }
      </style>
    </head>
    <body>
  `;

  // PAGE 1
  html += `
    <div class="page">
      <div class="header">
        <h1>Nutrient Management Plan</h1>
        <p>Customized Fertilizer Recommendation Report</p>
        <p style="margin-top: 2mm; font-size: 7.5pt; opacity: 0.9;">Powered by Insoil Soil Testing System</p>
      </div>

      <div class="section-title">TEST & CLIENT INFORMATION</div>
      <div class="info-grid">
        <div class="info-box">
          <label>Test ID</label>
          <div class="value">${escapeHtml(cfg.testId)}</div>
        </div>
        <div class="info-box">
          <label>Device ID</label>
          <div class="value">${escapeHtml(cfg.deviceId)}</div>
        </div>
        <div class="info-box">
          <label>Client Name</label>
          <div class="value">${escapeHtml(cfg.clientName || 'N/A')}</div>
        </div>
        <div class="info-box">
          <label>Client ID</label>
          <div class="value">${escapeHtml(cfg.clientId || 'N/A')}</div>
        </div>
      </div>

      <div class="section-title">CROP & METHOD DETAILS</div>
      <div class="info-grid">
        <div class="info-box">
          <label>Crop</label>
          <div class="value">${escapeHtml(cfg.cropName)}</div>
        </div>
        <div class="info-box">
          <label>Target Yield</label>
          <div class="value">${Number(cfg.targetYield).toFixed(2)} q/ha</div>
        </div>
        <div class="info-box">
          <label>Rating Scheme</label>
          <div class="value">${escapeHtml(cfg.ratingSchemeName || 'N/A')}</div>
        </div>
        <div class="info-box">
          <label>Method</label>
          <div class="value">${escapeHtml(cfg.methodName || 'N/A')}</div>
        </div>
      </div>

      <div class="section-title">RECOMMENDED NUTRIENT DOSES (kg/ha)</div>
      <div class="summary-box">
        <h4>Total Nutrient Requirement</h4>
        <div class="summary-row">
          <span class="label">Nitrogen (N)</span>
          <span class="value highlight">${Number(cfg.nRate).toFixed(1)} kg/ha</span>
        </div>
        <div class="summary-row">
          <span class="label">Phosphorus (P₂O₅)</span>
          <span class="value highlight">${Number(cfg.pRate).toFixed(1)} kg/ha</span>
        </div>
        <div class="summary-row">
          <span class="label">Potassium (K₂O)</span>
          <span class="value highlight">${Number(cfg.kRate).toFixed(1)} kg/ha</span>
        </div>
        <div class="summary-row" style="border-top: 1px solid ${colors.accentColor}; margin-top: 2mm; padding-top: 2mm;">
          <span class="label">TOTAL NPK</span>
          <span class="value highlight">${(Number(cfg.nRate) + Number(cfg.pRate) + Number(cfg.kRate)).toFixed(1)} kg/ha</span>
        </div>
      </div>

      <div class="footer">
        Report generated on ${new Date().toLocaleDateString('en-IN')} | Device: ${escapeHtml(cfg.deviceId)}
      </div>
      <div class="page-number">Page 1</div>
    </div>
  `;

  // PAGE 2
  html += `
    <div class="page">
      <div class="header">
        <h1>Stage-wise Application Schedule</h1>
        <p>Nutrient Timing & Application Strategy</p>
      </div>

      <div class="section-title">CROP GROWTH STAGES & NUTRIENT APPLICATION</div>
      <table>
        <thead>
          <tr>
            <th>Growth Stage</th>
            <th style="text-align: right;">N (kg/ha)</th>
            <th style="text-align: right;">P₂O₅ (kg/ha)</th>
            <th style="text-align: right;">K₂O (kg/ha)</th>
            <th style="text-align: right;">Total (kg/ha)</th>
          </tr>
        </thead>
        <tbody>
  `;

  let stageTotal = 0;
  if (cfg.stages && cfg.stages.length > 0) {
    const stageMap = {};
    cfg.stages.forEach(s => {
      const stageKey = s.stage || 'Unknown';
      if (!stageMap[stageKey]) {
        stageMap[stageKey] = { n: 0, p: 0, k: 0 };
      }
      if (s.nutrient === 'N') {
        stageMap[stageKey].n = Number(s.dose || 0);
      } else if (s.nutrient === 'P₂O₅') {
        stageMap[stageKey].p = Number(s.dose || 0);
      } else if (s.nutrient === 'K₂O') {
        stageMap[stageKey].k = Number(s.dose || 0);
      }
    });

    Object.entries(stageMap).forEach(([stage, doses], idx) => {
      const rowTotal = doses.n + doses.p + doses.k;
      stageTotal += rowTotal;
      html += `
        <tr>
          <td><strong>${escapeHtml(stage)}</strong></td>
          <td style="text-align: right;">${doses.n.toFixed(1)}</td>
          <td style="text-align: right;">${doses.p.toFixed(1)}</td>
          <td style="text-align: right;">${doses.k.toFixed(1)}</td>
          <td style="text-align: right; font-weight: 600;">${rowTotal.toFixed(1)}</td>
        </tr>
      `;
    });
  } else {
    html += `<tr><td colspan="5" style="text-align: center; color: ${colors.textSecondary};">No stage data available</td></tr>`;
  }

  html += `
        </tbody>
      </table>

      <div style="margin-top: 4mm; padding: 3mm 4mm; background: ${colors.tableHeaderBg}; border-radius: 3px; text-align: right; font-size: 8.5pt;">
        <strong style="color: ${colors.tableHeaderText};">Grand Total: ${stageTotal.toFixed(1)} kg/ha</strong>
      </div>

      <div class="footer">
        Ensure timely application at recommended stages for optimal crop nutrition
      </div>
      <div class="page-number">Page 2</div>
    </div>
  `;

  // PAGE 3 – Fertilizer materials (dynamic)
  html += `
    <div class="page">
      <div class="header">
        <h1>Recommended Fertilizer Materials</h1>
        <p>Specific Fertilizer Products & Application Rates</p>
      </div>

      <div class="section-title">FERTILIZER MATERIALS LIST</div>
      <div class="table-container">
        <div class="table-title">Fertilizer materials by stage</div>
        <table>
          <thead>
            <tr>
              <th>Stage</th>
              <th>Fertilizer Material</th>
              <th style="text-align: right;">Quantity (Bags/ha)</th>
              <th>Nutrient Content</th>
            </tr>
          </thead>
          <tbody>
  `;

  if (cfg.fertilizerMaterials && cfg.fertilizerMaterials.length) {
    cfg.fertilizerMaterials.forEach(function (row) {
      var stage = row.stage || '';
      var name = row.materialName || '';
      var qty = Number(row.qtyPerHa || 0);
      var nutr = row.nutrientContent || '';

      html += `
        <tr>
          <td>${escapeHtml(stage)}</td>
          <td>${escapeHtml(name)}</td>
          <td style="text-align: right;">${qty.toFixed(1)}</td>
          <td>${escapeHtml(nutr)}</td>
        </tr>
      `;
    });
  } else {
    html += `
      <tr>
        <td colspan="4" style="text-align:center; color:${colors.textSecondary};">
          No fertilizer material data available
        </td>
      </tr>
    `;
  }

  html += `
          </tbody>
        </table>
      </div>

      <div style="margin-top: 6mm; padding: 4mm 5mm; background: #F0F8FF; border-left: 3px solid ${colors.accentColor}; border-radius: 3px; font-size: 8pt;">
        <strong style="color: ${colors.headerBg};">Note:</strong>
        <span>
          Adjust fertilizer materials based on local availability and subsidy norms. Maintain soil moisture during fertilizer application for better nutrient use efficiency.
        </span>
      </div>

      <div class="footer">
        Always follow local regulations for fertilizer application
      </div>
      <div class="page-number">Page 3</div>
    </div>
  `;

  // PAGE 4 – Cost analysis (dynamic)
  var totalCost = 0;

  html += `
    <div class="page">
      <div class="header">
        <h1>Cost Analysis & Economics</h1>
        <p>Investment & Expected Returns</p>
      </div>

      <div class="section-title">FERTILIZER COST BREAKDOWN</div>
      <div class="table-container">
        <div class="table-title">Cost per hectare</div>
        <table>
          <thead>
            <tr>
              <th>Fertilizer Material</th>
              <th style="text-align: right;">Quantity (Bags/ha)</th>
              <th style="text-align: right;">Unit Price (₹/Bag)</th>
              <th style="text-align: right;">Total Cost (₹/ha)</th>
            </tr>
          </thead>
          <tbody>
  `;

  if (cfg.fertilizerCosts && cfg.fertilizerCosts.length) {
    cfg.fertilizerCosts.forEach(function (row) {
      var name = row.materialName || '';
      var qty = Number(row.qtyPerHa || 0);
      var unit = Number(row.unitPrice || 0);
      var lineTotal = row.totalCost != null ? Number(row.totalCost) : qty * unit;
      totalCost += lineTotal;

      html += `
        <tr>
          <td>${escapeHtml(name)}</td>
          <td style="text-align: right;">${qty.toFixed(1)}</td>
          <td style="text-align: right;">${unit.toFixed(2)}</td>
          <td style="text-align: right; font-weight: 600;">${lineTotal.toFixed(0)}</td>
        </tr>
      `;
    });
  } else {
    html += `
      <tr>
        <td colspan="4" style="text-align:center; color:${colors.textSecondary};">
          No fertilizer cost data available
        </td>
      </tr>
    `;
  }

  html += `
        <tr style="background: ${colors.tableHeaderBg};">
          <td colspan="3" style="text-align: right; font-weight: 700; color: ${colors.tableHeaderText};">
            TOTAL FERTILIZER COST
          </td>
          <td style="text-align: right; font-weight: 700; color: ${colors.tableHeaderText};">
            ₹${totalCost.toFixed(0)}/ha
          </td>
        </tr>
          </tbody>
        </table>
      </div>

      <div class="section-title">EXPECTED RETURNS</div>
      <div class="summary-box">
        <h4>Economic Analysis</h4>
        <div class="summary-row">
          <span class="label">Target Yield</span>
          <span class="value">${Number(cfg.targetYield).toFixed(1)} q/ha</span>
        </div>
        <div class="summary-row">
          <span class="label">Estimated Market Price</span>
          <span class="value">₹2,500/q</span>
        </div>
        <div class="summary-row">
          <span class="label">Gross Return</span>
          <span class="value highlight">₹${(Number(cfg.targetYield) * 2500).toFixed(0)}/ha</span>
        </div>
        <div class="summary-row">
          <span class="label">Fertilizer Investment</span>
          <span class="value">₹${totalCost.toFixed(0)}/ha</span>
        </div>
        <div class="summary-row" style="border-top: 1px solid ${colors.accentColor}; margin-top: 2mm; padding-top: 2mm;">
          <span class="label">Net Benefit (approx)</span>
          <span class="value highlight">
            ₹${((Number(cfg.targetYield) * 2500) - totalCost).toFixed(0)}/ha
          </span>
        </div>
      </div>

      <div style="margin-top: 5mm; padding: 4mm 5mm; background: #FFF8DC; border-left: 3px solid ${colors.accentColor}; border-radius: 3px; font-size: 8pt;">
        <strong style="color: ${colors.headerBg};">Important:</strong>
        <span>
          Economic estimates are indicative and based on assumed prices. Actual returns will depend on local market rates, seasonal variation, and crop management practices.
        </span>
      </div>

      <div class="footer">
        Consult with your local agricultural extension officer for location-specific recommendations
      </div>
      <div class="page-number">Page 4</div>
    </div>
  `;

  html += `
    </body>
    </html>
  `;

  return html;
}


function escapeHtml(text) {
  if (!text) return '';
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}




// Shared table header styling
function styleNmTableHeader_(table) {
  if (!table || table.getNumRows() === 0) return;

  var headerRow = table.getRow(0);
  var numCells = headerRow.getNumCells();

  for (var i = 0; i < numCells; i++) {
    var cell = headerRow.getCell(i);
    if (!cell) continue;
    try {
      cell.setBackgroundColor('#e2e8f0');
    } catch (e) { }

    var text = cell.editAsText();
    if (text) {
      text.setBold(true).setForegroundColor('#000000');
    }
  }

  table.setBorderWidth(1);
}

function testDebugStages() {
  const cropId = "WHEAT";
  const clientId = "Default";
  const methodId = "SOIL"; // or your method

  const summary = [
    { nutrient: 'N', baseDose: 120, doseMultiplier: 1 },
    { nutrient: 'P', baseDose: 60, doseMultiplier: 1 },
    { nutrient: 'K', baseDose: 120, doseMultiplier: 1 }
  ];

  const stages = buildGeneralStages_(summary, cropId, clientId, methodId, 'STD', 5);
  Logger.log('Stages length: ' + stages.length);
  Logger.log('First 3 stages: ' + JSON.stringify(stages.slice(0, 3)));
}



/***************************************************************
 * LAB VALIDATION MODULE - Backend (Code.gs)
 * Adds:
 *  - getSoilTestIndexForLabValidation()
 *  - getSoilTestRowForLabValidation(testId, deviceId)
 *  - saveLabValidationRows(payload)
 *  - ensureLabValidationDataSheet_()
 ***************************************************************/

function _lvNormId_(v) {
  // normalize values to a comparable ID string
  let s = String(v == null ? '' : v).trim();

  // common sheet numeric artifacts: "862.0"
  s = s.replace(/\.0$/, '');

  // collapse multiple spaces
  s = s.replace(/\s+/g, ' ');

  return s;
}

function getSoilTestIndexForLabValidation() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const sh =
    ss.getSheetByName('SoilTest_Result') ||
    ss.getSheetByName('SoilTest_Results');

  if (!sh) {
    return { ok: false, msg: 'Missing sheet: SoilTest_Result / SoilTest_Results', tests: [], devices: [], pairs: [], counts: { tests: 0, devices: 0, rows: 0 } };
  }

  const range = sh.getDataRange();
  const display = range.getDisplayValues();   // ✅ IMPORTANT
  if (display.length < 2) {
    return { ok: true, msg: 'No rows in SoilTest sheet.', tests: [], devices: [], pairs: [], counts: { tests: 0, devices: 0, rows: 0 } };
  }

  const headers = display[0].map(h => String(h).trim());
  const idxTest = headers.indexOf('Test_ID');
  const idxDev = headers.indexOf('Device_ID');

  if (idxTest === -1 || idxDev === -1) {
    return { ok: false, msg: 'SoilTest sheet must contain headers Test_ID and Device_ID', tests: [], devices: [], pairs: [], counts: { tests: 0, devices: 0, rows: display.length - 1 } };
  }

  const testsSet = {};
  const devSet = {};
  const pairs = [];

  for (let r = 1; r < display.length; r++) {
    const testId = _lvNormId_(display[r][idxTest]);
    const deviceId = _lvNormId_(display[r][idxDev]);
    if (!testId || !deviceId) continue;

    testsSet[testId] = true;
    devSet[deviceId] = true;
    pairs.push({ testId, deviceId });
  }

  const tests = Object.keys(testsSet).sort();
  const devices = Object.keys(devSet).sort();

  return {
    ok: true,
    msg: 'Loaded SoilTest index.',
    tests,
    devices,
    pairs,
    counts: { tests: tests.length, devices: devices.length, rows: display.length - 1 }
  };
}

function getSoilTestRowForLabValidation(testId, deviceId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh =
    ss.getSheetByName('SoilTest_Result') ||
    ss.getSheetByName('SoilTest_Results');

  if (!sh) throw new Error('Missing sheet: SoilTest_Result / SoilTest_Results');

  const display = sh.getDataRange().getDisplayValues(); // ✅ IMPORTANT
  if (display.length < 2) return null;

  const headers = display[0].map(h => String(h).trim());
  const idxTest = headers.indexOf('Test_ID');
  const idxDev = headers.indexOf('Device_ID');

  if (idxTest === -1 || idxDev === -1) {
    throw new Error('SoilTest sheet must contain Test_ID and Device_ID headers.');
  }

  const wantedTest = _lvNormId_(testId);
  const wantedDev = _lvNormId_(deviceId);

  let row = null;

  // strict match by BOTH
  for (let r = 1; r < display.length; r++) {
    const t = _lvNormId_(display[r][idxTest]);
    const d = _lvNormId_(display[r][idxDev]);
    if (t === wantedTest && d === wantedDev) {
      row = display[r];
      break;
    }
  }

  // fallback match by Test_ID only (if device empty or mismatch)
  if (!row && wantedTest) {
    for (let r = 1; r < display.length; r++) {
      const t = _lvNormId_(display[r][idxTest]);
      if (t === wantedTest) {
        row = display[r];
        break;
      }
    }
  }

  if (!row) return null;

  // Build a row object by headers
  const rowObj = {};
  headers.forEach((h, i) => rowObj[h] = row[i]);

  // Return the lab validation subset
  return {
    Test_ID: rowObj['Test_ID'] || '',
    Device_ID: rowObj['Device_ID'] || '',
    ClientID: rowObj['ClientID'] || '',
    Farm_ID: rowObj['Farm_ID'] || '',
    Date: rowObj['Date'] || '',
    Crop: rowObj['Crop'] || '',
    pH: rowObj['pH'] || '',
    EC: rowObj['EC'] || '',
    OC: rowObj['OC'] || '',
    Avail_N: rowObj['Avail_N'] || '',
    Avail_P: rowObj['Avail_P'] || '',
    Avail_K: rowObj['Avail_K'] || '',
    Avail_S: rowObj['Avail_S'] || '',
    Zn: rowObj['Zn'] || '',
    Fe: rowObj['Fe'] || '',
    Mn: rowObj['Mn'] || '',
    Cu: rowObj['Cu'] || '',
    B: rowObj['B'] || ''
  };
}


function saveLabValidationRows(payload) {
  // payload: { meta:{...}, rows:[{Parameter,Unit,Lab_Value,Insoil_Value,Notes}] }
  ensureLabValidationDataSheet_();

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('Lab_Validation_Data');
  if (!sh) throw new Error('Could not create Lab_Validation_Data');

  const meta = payload && payload.meta ? payload.meta : {};
  const rows = payload && Array.isArray(payload.rows) ? payload.rows : [];

  if (!rows.length) return { ok: false, msg: 'No rows to save.' };

  const ts = new Date();
  const deviceId = meta.Device_ID || '';
  const testId = meta.Test_ID || '';
  const labName = meta.Lab_Name || '';
  const labAddr = meta.Lab_Address || '';
  const labLoc = meta.Lab_Location || '';
  const labGPS = meta.Lab_GPS || '';
  const enteredBy = meta.Entered_By || '';
  const methodNotes = meta.Method_Notes || '';

  const out = rows.map(r => ([
    ts,
    deviceId,
    testId,
    labName,
    labAddr,
    labLoc,
    labGPS,
    r.Parameter || '',
    r.Unit || '',
    r.Lab_Value ?? '',
    r.Insoil_Value ?? '',
    methodNotes,
    enteredBy
  ]));

  sh.getRange(sh.getLastRow() + 1, 1, out.length, out[0].length).setValues(out);
  return { ok: true, msg: `Saved ${out.length} row(s).` };
}

function ensureLabValidationDataSheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName('Lab_Validation_Data');
  const headers = [
    'Timestamp',
    'Device_ID',
    'Test_ID',
    'Lab_Name',
    'Lab_Address',
    'Lab_Location',
    'Lab_GPS',
    'Parameter',
    'Unit',
    'Lab_Value',
    'Insoil_Value (auto)',
    'Method_Notes',
    'Entered_By'
  ];

  if (!sh) {
    sh = ss.insertSheet('Lab_Validation_Data');
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sh;
  }

  // If sheet exists but headers differ, do NOT wipe user data. Only add header row if missing.
  const firstRow = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0].map(String);
  const hasTimestamp = firstRow.indexOf('Timestamp') !== -1;
  if (!hasTimestamp) {
    sh.insertRowBefore(1);
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
  }
  return sh;
}


function getLabValidationScatterData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("Lab_Validation_Data");
  if (!sh) return { ok: true, rows: [] };

  const values = sh.getDataRange().getDisplayValues();
  if (values.length < 2) return { ok: true, rows: [] };

  const headers = values[0].map(h => String(h).trim());
  const idxParam = headers.indexOf("Parameter");
  const idxX = headers.indexOf("Insoil_Value (auto)");
  const idxY = headers.indexOf("Lab_Value");

  if (idxParam === -1 || idxX === -1 || idxY === -1) {
    return { ok: false, msg: "Missing required columns: Parameter, Insoil_Value (auto), Lab_Value" };
  }

  const out = [];
  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const param = String(row[idxParam] || "").trim();

    const x = parseFloat(String(row[idxX] || "").replace(/,/g, "").trim());
    const y = parseFloat(String(row[idxY] || "").replace(/,/g, "").trim());

    if (!param || !Number.isFinite(x) || !Number.isFinite(y)) continue;
    out.push({ param, x, y });
  }

  return { ok: true, rows: out };
}


/***********************
 * STV RUN LOG (IMMUTABLE)
 ***********************/
function ensureSTVUpdateLogSheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName("STV_Update_Log");
  const headers = [
    "STV_Run_ID",
    "Saved_At",
    "Saved_By",
    "STV_Version",
    "Parameter",
    "a", "b", "df1", "df2", "df3", "df4",
    "Payload_JSON"
  ];
  if (!sh) {
    sh = ss.insertSheet("STV_Update_Log");
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sh;
  }
  // If sheet exists but header missing, insert a header row (do NOT clear data).
  const firstRow = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0].map(String);
  if (firstRow.join() !== headers.join()) {
    sh.insertRowBefore(1);
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
  }
  return sh;
}

function generateSTVRunId_() {
  const ts = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd-HHmmss");
  const rand = Math.floor(1000 + Math.random() * 9000);
  return "STV-" + ts + "-" + rand;
}

/**
 * Append immutable snapshot rows for the STV just saved.
 * d = [{p,a,b,df1,df2,df3,df4}, ...] OR same object keys already used in your saveSTVEquations.
 */
function appendSTVRunLog_(d, stvVersion) {
  const sh = ensureSTVUpdateLogSheet_();
  const runId = generateSTVRunId_();
  const now = new Date();
  const email = (function () {
    try { return Session.getActiveUser().getEmail(); } catch (e) { return ""; }
  })();

  const payloadJson = JSON.stringify({
    stvRunId: runId,
    savedAt: now.toISOString(),
    stvVersion: stvVersion || "",
    stv: d
  });

  const rows = (d || []).map(o => ([
    runId,
    now,
    email,
    stvVersion || "",
    o.p,
    o.a, o.b, o.df1, o.df2, o.df3, o.df4,
    payloadJson
  ]));

  if (rows.length) sh.getRange(sh.getLastRow() + 1, 1, rows.length, rows[0].length).setValues(rows);
  return { runId: runId, savedAt: now };
}

function getLatestSTVRunMeta_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('STV_Update_Log');
  if (!sh || sh.getLastRow() < 2) return null;

  // last appended row contains same run id for that run
  const last = sh.getRange(sh.getLastRow(), 1, 1, 4).getValues()[0];
  return { stvRunId: last[0], stvSavedAt: last[1], stvVersion: last[3] };
}

function ensureSTVRunMetaExists_() {
  const meta = getLatestSTVRunMeta_();
  if (meta && meta.stvRunId) return meta;

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const stvRows = getDataByHeaders(ss, 'STV', ['Parameter', 'a', 'b', 'df1', 'df2', 'df3', 'df4']);
  const stvArray = stvRows.map(r => ({ p: r[0], a: r[1], b: r[2], df1: r[3], df2: r[4], df3: r[5], df4: r[6] }));

  let version = getCurrentSTVVersion_();
  if (!version) {
    version = new Date().toISOString();
    setCurrentSTVVersion_(version);
  }

  const run = appendSTVRunLog_(stvArray, version);
  return { stvRunId: run.stvRunId, stvSavedAt: run.stvSavedAt, stvVersion: version };
}


function createSTVUpdateLogSheet() {
  return ensureSTVUpdateLogSheet_();
}


function createSTVRunNow() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const stvRows = getDataByHeaders(ss, 'STV', ['Parameter', 'a', 'b', 'df1', 'df2', 'df3', 'df4']);
  const stvArray = stvRows.map(r => ({ p: r[0], a: r[1], b: r[2], df1: r[3], df2: r[4], df3: r[5], df4: r[6] }));

  let version = getCurrentSTVVersion_();
  if (!version) {
    version = new Date().toISOString();
    setCurrentSTVVersion_(version);
  }

  return appendSTVRunLog_(stvArray, version); // this will create STV_Update_Log too
}


function toSig2_(v) {
  if (v === '' || v === null || v === undefined) return '';
  const n = Number(v);
  if (!isFinite(n)) return '';
  if (n === 0) return 0;
  return Number(n.toPrecision(2)); // 2 significant figures [web:524]
}

function normalizeToISODate_(v) {
  if (v === null || v === undefined || v === '') return '';

  // If already a Date object
  if (v instanceof Date && !isNaN(v.getTime())) {
    return Utilities.formatDate(v, Session.getScriptTimeZone(), 'yyyy-MM-dd');
  }

  // If Google Sheets serial date number
  if (typeof v === 'number' && isFinite(v)) {
    var d = new Date(Math.round((v - 25569) * 86400 * 1000));
    if (!isNaN(d.getTime())) return Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy-MM-dd');
  }

  var s = String(v).trim();

  // Already ISO yyyy-mm-dd
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;

  // dd-mm-yyyy or dd/mm/yyyy
  var m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) {
    var dd = ('0' + m[1]).slice(-2);
    var mm = ('0' + m[2]).slice(-2);
    var yyyy = m[3];
    return yyyy + '-' + mm + '-' + dd;
  }

  // If it’s some other string, leave it (or return blank)
  return s;
}


function fixSoilTestResultsDateColumn_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('SoilTest_Results');
  if (!sh) throw new Error('SoilTestResults not found');

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h).trim());
  const idx = headers.indexOf('Date');
  if (idx === -1) throw new Error('Date column not found');

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return 'No rows';

  const rng = sh.getRange(2, idx + 1, lastRow - 1, 1);
  const vals = rng.getValues(); // may contain Date, number, or string

  const out = vals.map(r => [parseToDateObject_(r[0])]);
  rng.setValues(out);

  rng.setNumberFormat('yyyy/MM/dd');
  return `Fixed ${out.length} rows.`;
}



function runFixSoilTestResultsDate() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('SoilTest_Results');
  if (!sh) throw new Error('SoilTestResults not found');

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h).trim());
  const idx = headers.indexOf('Date');
  if (idx === -1) throw new Error('Date column not found');

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;

  const rng = sh.getRange(2, idx + 1, lastRow - 1, 1);
  const vals = rng.getValues();

  // Convert everything to Date objects (where possible)
  const out = vals.map(r => [parseToDateObject_(r[0]) || '']);
  rng.setValues(out);

  // Force display format
  rng.setNumberFormat('yyyy/MM/dd');
}


function _cleanAndFormatSoilResultsDateColumn_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('SoilTest_Results');
  if (!sh) return;

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h).trim());
  const idx = headers.indexOf('Date');
  if (idx === -1) return;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;

  const rng = sh.getRange(2, idx + 1, lastRow - 1, 1);
  const vals = rng.getValues();

  // Convert any strings to Date objects
  const out = vals.map(r => {
    const v = r[0];
    if (v instanceof Date && !isNaN(v.getTime())) return [v];
    const d = parseToDateObject_(v);
    return [d || ''];
  });

  rng.setValues(out);
  rng.setNumberFormat('yyyy/MM/dd');  // This forces date format
}

function resetAndRerunOverride() {
  PropertiesService.getScriptProperties().deleteProperty('STV_OVERRIDE_CURSOR');

  // Delete all triggers for overrideSTVForAllTests
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'overrideSTVForAllTests') {
      ScriptApp.deleteTrigger(t);
    }
  });

  // Run once
  overrideSTVForAllTests();
}



function forceStopSTVOverride() {
  const CURSOR_KEY = 'STV_OVERRIDE_CURSOR';
  const HANDLER = 'overrideSTVForAllTests';

  // 1. Delete the cursor (stops resume on next trigger)
  const props = PropertiesService.getScriptProperties();
  const currentCursor = props.getProperty(CURSOR_KEY);

  if (currentCursor) {
    props.deleteProperty(CURSOR_KEY);
    Logger.log('✓ Deleted cursor at position: ' + currentCursor);
  } else {
    Logger.log('⚠ No active cursor found (process may not be running)');
  }

  // 2. Delete all time-based triggers for the handler
  const triggers = ScriptApp.getProjectTriggers();
  let deletedCount = 0;

  triggers.forEach(function (t) {
    if (t.getHandlerFunction() === HANDLER) {
      ScriptApp.deleteTrigger(t);
      deletedCount++;
    }
  });

  Logger.log('✓ Deleted ' + deletedCount + ' trigger(s) for ' + HANDLER);

  // 3. Return summary
  const summary = {
    status: 'STOPPED',
    cursorDeleted: currentCursor ? true : false,
    lastPosition: currentCursor || 'N/A',
    triggersDeleted: deletedCount,
    timestamp: new Date().toISOString()
  };

  Logger.log('=== STV Override Process FORCE STOPPED ===');
  Logger.log(JSON.stringify(summary, null, 2));

  return summary;
}


/* ---------- helpers ---------- */

function makeHeaderIndex_(hdr) {
  const idx = {};
  hdr.forEach((h, i) => { idx[String(h)] = i; });
  return idx;
}

function requireCols_(idx, cols) {
  cols.forEach(c => {
    if (idx[c] == null) throw new Error(`Required column '${c}' not found in sheet header.`);
  });
}

function canonicalDateKey_(v) {
  // Returns a stable key string: "yyyy-MM-dd HH:mm"
  // Accepts: Date object, "yyyy-mm-dd | HH:mm", "yyyy-mm-dd", "MM/DD/YYYY", "dd-mm-yyyy", etc.
  if (v == null || v === '') return '';

  // GAS Date object
  if (Object.prototype.toString.call(v) === '[object Date]') {
    const d = v;
    if (!isNaN(d.getTime())) {
      return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
    }
    return '';
  }

  const s0 = String(v).trim();
  if (!s0) return '';

  // "yyyy-mm-dd | HH:mm" -> "yyyy-mm-dd HH:mm"
  const s = s0.includes('|') ? s0.replace(/\s*\|\s*/g, ' ') : s0;

  // Try native parse first
  let d = new Date(s);
  if (!isNaN(d.getTime())) {
    return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
  }

  // Try "MM/DD/YYYY" or "MM/DD/YYYY HH:mm"
  let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
  if (m) {
    const mm = Number(m[1]) - 1;
    const dd = Number(m[2]);
    const yy = Number(m[3]);
    const HH = Number(m[4] || 0);
    const MI = Number(m[5] || 0);
    d = new Date(yy, mm, dd, HH, MI, 0);
    if (!isNaN(d.getTime())) {
      return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
    }
  }

  // Try "dd-mm-yyyy" or "dd/mm/yyyy" (optionally time)
  m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
  if (m) {
    const dd = Number(m[1]);
    const mm = Number(m[2]) - 1;
    const yy = Number(m[3]);
    const HH = Number(m[4] || 0);
    const MI = Number(m[5] || 0);
    d = new Date(yy, mm, dd, HH, MI, 0);
    if (!isNaN(d.getTime())) {
      return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
    }
  }

  // Last resort: keep raw trimmed (still deterministic, but may not match other formats)
  return s0;
}

function makeKey_(deviceId, testId, dateStr) {
  const did = String(deviceId || '').trim();
  const tid = String(testId || '').trim();
  const dtk = canonicalDateKey_(dateStr);
  return `${did}|${tid}|${dtk}`;
}



// ========= AI FUNCTIONALITY start =============//

// SERVER-SIDE Apps Script
// Add your Mistral (or proxy) API URL and key
const MISTRAL_ENDPOINT = 'https://api.mistral.ai/v1/chat/completions';  // or your proxy URL
const MISTRAL_API_KEY = 'wHCSFUe0n2lsaKoa1q9QbM5mPCBv6zuf';  // your real key


function aiQCDiagnoseMistral(payloadJson) {
  try {
    const payload = JSON.parse(payloadJson || '{}');

    const systemPrompt =
      'You are a lab quality control expert for an on-farm soil testing device. ' +
      'You receive JSON with QC results and must answer in JSON.\n' +
      'CRITICAL: Return ONLY a single JSON object. Do not add explanations, text, or code fences. ' +
      'Do NOT wrap the JSON in ```json or any other markers.\n' +
      'The JSON schema is: ' +
      '{ "summary": string, "riskLevel": "low" | "medium" | "high", ' +
      '"likelyCauses": [{ "cause": string, "evidence": string }], ' +
      '"nextChecks": [{ "priority": number, "step": string }] }.';


    const userContent = JSON.stringify(payload);

    const reqBody = {
      model: 'mistral-small-latest',  // or whatever you actually use
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userContent }
      ],
      temperature: 0.2,
      max_tokens: 300
    };

    const options = {
      method: 'post',
      contentType: 'application/json',
      headers: {
        Authorization: 'Bearer ' + MISTRAL_API_KEY
      },
      payload: JSON.stringify(reqBody),
      muteHttpExceptions: true
    };

    const resp = UrlFetchApp.fetch(MISTRAL_ENDPOINT, options);
    const code = resp.getResponseCode();
    if (code < 200 || code >= 300) {
      throw new Error('Mistral HTTP ' + code + ': ' + resp.getContentText());
    }

    const data = JSON.parse(resp.getContentText());
    // Adjust path depending on your provider
    const content = data.choices && data.choices[0] && data.choices[0].message &&
      data.choices[0].message.content;
    if (!content) throw new Error('Empty AI response.');

    // AI returns JSON as text, parse it safely
    // Normalise content: strip Markdown code fences if present
    let cleaned = content.trim();

    // remove leading ```json or ```JSON or ``` if present
    if (cleaned.startsWith('```')) {
      // drop first line (``` or ```json)
      const lines = cleaned.split('\n');
      // remove first line and any trailing ``` line
      if (lines.length >= 2) {
        // remove first
        lines.shift();
        // if last line is ``` remove it
        if (lines[lines.length - 1].trim().startsWith('```')) {
          lines.pop();
        }
        cleaned = lines.join('\n').trim();
      }
    }

    let diag;
    try {
      diag = JSON.parse(cleaned);
    } catch (e) {
      throw new Error('AI JSON parse error: ' + e.message + ' | raw: ' + cleaned);
    }


    // Minimal schema check
    if (!diag.summary || !diag.nextChecks) {
      throw new Error('AI diagnostics missing required fields.');
    }

    return {
      ok: true,
      diagnostics: diag
    };
  } catch (e) {
    Logger.log('aiQCDiagnoseMistral error: ' + e.message);
    return {
      ok: false,
      message: 'AI QC error: ' + e.message
    };
  }
}

// ========= AI FUNCTIONALITY end =============//


// CONFIG: name of the sheet that holds recipe definitions
const RECIPE_SHEET_NAME = 'QC_Recipes';

/**
 * Read QC_Recipes and build a map:
 * { S: { paramName, steps: [...] }, N: {...}, ... }
 */
function loadRecipeConfig_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(RECIPE_SHEET_NAME);
  if (!sh) throw new Error('Sheet not found: ' + RECIPE_SHEET_NAME);

  const values = sh.getDataRange().getValues();
  if (values.length < 2) return {};

  const headers = values[0].map(String);
  const rows = values.slice(1);

  // Helper to read a field by header name safely
  const idx = name => {
    const i = headers.indexOf(name);
    return i === -1 ? null : i;
  };

  const ixParamCode = idx('param_code');
  const ixParamName = idx('param_name');
  const ixStepOrder = idx('step_order');
  const ixStepId = idx('step_id');
  const ixHardwareId = idx('hardware_id');
  const ixStepType = idx('step_type');
  const ixVolume = idx('volume_ml');
  const ixTime = idx('time_s');
  const ixBand = idx('band');
  const ixSeverity = idx('severity');
  const ixNotes = idx('notes');

  const byParam = {};

  rows.forEach(r => {
    const paramCode = ixParamCode != null ? String(r[ixParamCode] || '').trim() : '';
    if (!paramCode) return;

    if (!byParam[paramCode]) {
      byParam[paramCode] = {
        paramCode,
        paramName: ixParamName != null ? String(r[ixParamName] || '').trim() : paramCode,
        steps: []
      };
    }

    const step = {
      stepOrder: ixStepOrder != null ? Number(r[ixStepOrder] || 0) : 0,
      stepId: ixStepId != null ? String(r[ixStepId] || '').trim() : '',
      hardwareId: ixHardwareId != null ? String(r[ixHardwareId] || '').trim() : '',
      stepType: ixStepType != null ? String(r[ixStepType] || '').trim() : '',
      volumeMl: ixVolume != null && r[ixVolume] !== '' ? Number(r[ixVolume]) : null,
      timeSec: ixTime != null && r[ixTime] !== '' ? Number(r[ixTime]) : null,
      band: ixBand != null ? String(r[ixBand] || '').trim() : '',
      severity: ixSeverity != null && r[ixSeverity] !== '' ? Number(r[ixSeverity]) : 0,
      notes: ixNotes != null ? String(r[ixNotes] || '').trim() : ''
    };

    byParam[paramCode].steps.push(step);
  });

  // Sort steps and compute normalized weights per parameter
  Object.values(byParam).forEach(cfg => {
    cfg.steps.sort((a, b) => a.stepOrder - b.stepOrder);
    const totalSeverity = cfg.steps.reduce((s, st) => s + (st.severity || 0), 0) || 1;
    cfg.steps.forEach(st => {
      st.normalizedWeight = (st.severity || 0) / totalSeverity;
    });
  });

  return byParam;
}

//=================================== NEW IMPLEMENTATION ============================================//


/**
 * srvr_CreateRGBData_ImportCSV_appendtoRGB_dedup
 * 
 * V7: FIXED PARSING. Uses a robust CSV parser to handle quoted strings and 
 * empty columns correctly, preventing data shifts.
 */
function srvr_CreateRGBData_ImportCSV_appendtoRGB_dedup(payload) {
  if (!payload || typeof payload.csvText !== 'string') {
    throw new Error("Invalid payload: 'csvText' string is required.");
  }

  const csvText = payload.csvText;

  // ✅ Meta defaulting (server-side, so UI never has to fake defaults)
  const metaIn = payload.meta || {};
  const defMeta = (v, d = "Default") => {
    const s = String(v ?? "").trim();
    return s ? s : d;
  };
  const meta = {
    Client_ID: defMeta(metaIn.Client_ID),
    Farm_ID: defMeta(metaIn.Farm_ID),
    ProdBatch_ID: defMeta(metaIn.ProdBatch_ID),
    QCBatch_ID: defMeta(metaIn.QCBatch_ID)
  };

  // --- 1. CONFIGURATION ---
  const HEADERS_META = ["QC", "Client_ID", "Farm_ID", "ProdBatch_ID", "QCBatch_ID", "Device_ID", "Test_ID", "Test_date"];
  const HEADERS_RGB_AUDIT = [
    "NH4N_S1_RGB_T", "NH4N_S1_RGB_C", "B_S1_RGB_T", "B_S1_RGB_C", "Cu_S2_RGB_T", "Cu_S2_RGB_C",
    "EC_S0_RGB_T", "EC_S0_RGB_C", "Fe_S2_RGB_T", "Fe_S2_RGB_C", "Mn_S2_RGB_T", "Mn_S2_RGB_C",
    "NO3N_S1_RGB_T", "NO3N_S1_RGB_C", "OC_S1_RGB_T", "OC_S1_RGB_C", "pH_S0_RGB_T", "pH_S0_RGB_C",
    "P_S1_RGB_T", "P_S1_RGB_C", "K_S2_RGB_T", "K_S2_RGB_C", "S_S1_RGB_T", "S_S1_RGB_C",
    "ZnCu_S2_RGB_T", "ZnCu_S2_RGB_C"
  ];
  const HEADERS_DATA_INT = [
    "NH4N_S1_B_T", "NH4N_S1_B_C", "B_S1_B_T", "B_S1_B_C", "Cu_S2_R_T", "Cu_S2_R_C",
    "EC_S0_R_T", "EC_S0_R_C", "Fe_S2_G_T", "Fe_S2_G_C", "Mn_S2_G_T", "Mn_S2_G_C",
    "NO3N_S1_G_T", "NO3N_S1_G_C", "OC_S1_G_T", "OC_S1_G_C", "pH_S0_R_T", "pH_S0_R_C",
    "P_S1_B_T", "P_S1_B_C", "K_S2_B_T", "K_S2_B_C", "S_S1_B_T", "S_S1_B_C",
    "ZnCu_S2_R_T", "ZnCu_S2_R_C"
  ];
  const HEADERS_CALC = [
    "bn", "NH4N_Abs", "B_Abs", "Cu_Abs", "EC_Val", "Fe_Abs", "Mn_Abs",
    "NO3N_Abs", "OC_Abs", "pH_Val", "P_Abs", "K_Abs", "S_Abs", "ZnCu_Abs"
  ];
  const RGB_HEADERS = [...HEADERS_META, ...HEADERS_RGB_AUDIT, ...HEADERS_DATA_INT, ...HEADERS_CALC];

  const MAP_BY_HEADER = [
    { csv: "device_id", head: "Device_ID", type: "device_sci" },
    { csv: "test_id", head: "Test_ID", type: "string" },
    { csv: "date", head: "Test_date", type: "date_any" },
    { csv: "amnm_n", head: "NH4N_S1_B_T", type: "triplet", band: 2, auditHead: "NH4N_S1_RGB_T" },
    { csv: "amnm_n_cal", head: "NH4N_S1_B_C", type: "triplet", band: 2, auditHead: "NH4N_S1_RGB_C" },
    { csv: "brn", head: "B_S1_B_T", type: "triplet", band: 2, auditHead: "B_S1_RGB_T" },
    { csv: "brn_cal", head: "B_S1_B_C", type: "triplet", band: 2, auditHead: "B_S1_RGB_C" },
    { csv: "cpr", head: "Cu_S2_R_T", type: "triplet", band: 0, auditHead: "Cu_S2_RGB_T" },
    { csv: "cpr_cal", head: "Cu_S2_R_C", type: "triplet", band: 0, auditHead: "Cu_S2_RGB_C" },
    { csv: "ec", head: "EC_S0_R_T", type: "triplet", band: 0, auditHead: "EC_S0_RGB_T" },
    { csv: "ec_cal", head: "EC_S0_R_C", type: "triplet", band: 0, auditHead: "EC_S0_RGB_C" },
    { csv: "irn", head: "Fe_S2_G_T", type: "triplet", band: 1, auditHead: "Fe_S2_RGB_T" },
    { csv: "irn_cal", head: "Fe_S2_G_C", type: "triplet", band: 1, auditHead: "Fe_S2_RGB_C" },
    { csv: "mgns", head: "Mn_S2_G_T", type: "triplet", band: 1, auditHead: "Mn_S2_RGB_T" },
    { csv: "mgns_cal", head: "Mn_S2_G_C", type: "triplet", band: 1, auditHead: "Mn_S2_RGB_C" },
    { csv: "ntrt_n", head: "NO3N_S1_G_T", type: "triplet", band: 1, auditHead: "NO3N_S1_RGB_T" },
    { csv: "ntrt_n_cal", head: "NO3N_S1_G_C", type: "triplet", band: 1, auditHead: "NO3N_S1_RGB_C" },
    { csv: "org_crbn", head: "OC_S1_G_T", type: "triplet", band: 1, auditHead: "OC_S1_RGB_T" },
    { csv: "org_crbn_cal", head: "OC_S1_G_C", type: "triplet", band: 1, auditHead: "OC_S1_RGB_C" },
    { csv: "ph", head: "pH_S0_R_T", type: "triplet", band: 0, auditHead: "pH_S0_RGB_T" },
    { csv: "ph_cal", head: "pH_S0_R_C", type: "triplet", band: 0, auditHead: "pH_S0_RGB_C" },
    { csv: "phprs", head: "P_S1_B_T", type: "triplet", band: 2, auditHead: "P_S1_RGB_T" },
    { csv: "phprs_cal", head: "P_S1_B_C", type: "triplet", band: 2, auditHead: "P_S1_RGB_C" },
    { csv: "potsm", head: "K_S2_B_T", type: "triplet", band: 2, auditHead: "K_S2_RGB_T" },
    { csv: "potsm_cal", head: "K_S2_B_C", type: "triplet", band: 2, auditHead: "K_S2_RGB_C" },
    { csv: "slpr", head: "S_S1_B_T", type: "triplet", band: 2, auditHead: "S_S1_RGB_T" },
    { csv: "slpr_cal", head: "S_S1_B_C", type: "triplet", band: 2, auditHead: "S_S1_RGB_C" },
    { csv: "znc", head: "ZnCu_S2_R_T", type: "triplet", band: 0, auditHead: "ZnCu_S2_RGB_T" },
    { csv: "znc_cal", head: "ZnCu_S2_R_C", type: "triplet", band: 0, auditHead: "ZnCu_S2_RGB_C" },
    { csv: "bn", head: "bn", type: "string" }
  ];

  // Legacy positional mapping (backward compatibility)
  const MAP_LEGACY = [
    { head: "Device_ID", logicIdx: 0, type: "device_sci" },
    { head: "Test_ID", logicIdx: 1, type: "string" },
    { head: "Test_date", logicIdx: 2, type: "date_any" },
    { head: "NH4N_S1_B_T", logicIdx: 3, type: "triplet", band: 2, auditHead: "NH4N_S1_RGB_T" },
    { head: "NH4N_S1_B_C", logicIdx: 4, type: "triplet", band: 2, auditHead: "NH4N_S1_RGB_C" },
    { head: "B_S1_B_T", logicIdx: 5, type: "triplet", band: 2, auditHead: "B_S1_RGB_T" },
    { head: "B_S1_B_C", logicIdx: 6, type: "triplet", band: 2, auditHead: "B_S1_RGB_C" },
    { head: "Cu_S2_R_T", logicIdx: 7, type: "triplet", band: 0, auditHead: "Cu_S2_RGB_T" },
    { head: "Cu_S2_R_C", logicIdx: 8, type: "triplet", band: 0, auditHead: "Cu_S2_RGB_C" },
    { head: "EC_S0_R_T", logicIdx: 9, type: "triplet", band: 0, auditHead: "EC_S0_RGB_T" },
    { head: "EC_S0_R_C", logicIdx: 10, type: "triplet", band: 0, auditHead: "EC_S0_RGB_C" },
    { head: "Fe_S2_G_T", logicIdx: 11, type: "triplet", band: 1, auditHead: "Fe_S2_RGB_T" },
    { head: "Fe_S2_G_C", logicIdx: 12, type: "triplet", band: 1, auditHead: "Fe_S2_RGB_C" },
    { head: "Mn_S2_G_T", logicIdx: 13, type: "triplet", band: 1, auditHead: "Mn_S2_RGB_T" },
    { head: "Mn_S2_G_C", logicIdx: 14, type: "triplet", band: 1, auditHead: "Mn_S2_RGB_C" },
    { head: "NO3N_S1_G_T", logicIdx: 15, type: "triplet", band: 1, auditHead: "NO3N_S1_RGB_T" },
    { head: "NO3N_S1_G_C", logicIdx: 16, type: "triplet", band: 1, auditHead: "NO3N_S1_RGB_C" },
    { head: "OC_S1_G_T", logicIdx: 17, type: "triplet", band: 1, auditHead: "OC_S1_RGB_T" },
    { head: "OC_S1_G_C", logicIdx: 18, type: "triplet", band: 1, auditHead: "OC_S1_RGB_C" },
    { head: "pH_S0_R_T", logicIdx: 19, type: "triplet", band: 0, auditHead: "pH_S0_RGB_T" },
    { head: "pH_S0_R_C", logicIdx: 20, type: "triplet", band: 0, auditHead: "pH_S0_RGB_C" },
    { head: "P_S1_B_T", logicIdx: 21, type: "triplet", band: 2, auditHead: "P_S1_RGB_T" },
    { head: "P_S1_B_C", logicIdx: 22, type: "triplet", band: 2, auditHead: "P_S1_RGB_C" },
    { head: "K_S2_B_T", logicIdx: 23, type: "triplet", band: 2, auditHead: "K_S2_RGB_T" },
    { head: "K_S2_B_C", logicIdx: 24, type: "triplet", band: 2, auditHead: "K_S2_RGB_C" },
    { head: "S_S1_B_T", logicIdx: 25, type: "triplet", band: 2, auditHead: "S_S1_RGB_T" },
    { head: "S_S1_B_C", logicIdx: 26, type: "triplet", band: 2, auditHead: "S_S1_RGB_C" },
    { head: "ZnCu_S2_R_T", logicIdx: 27, type: "triplet", band: 0, auditHead: "ZnCu_S2_RGB_T" },
    { head: "ZnCu_S2_R_C", logicIdx: 28, type: "triplet", band: 0, auditHead: "ZnCu_S2_RGB_C" },
    { head: "bn", logicIdx: 31, type: "string" }
  ];

  // --- 2. SHEET PREP ---
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName("RGB_Data");

  if (sh) {
    sh.getRange(1, 1, 1, RGB_HEADERS.length).setValues([RGB_HEADERS]);
  } else {
    sh = ss.insertSheet("RGB_Data");
    sh.getRange(1, 1, 1, RGB_HEADERS.length).setValues([RGB_HEADERS]);
    sh.setFrozenRows(1);
  }

  // --- 3. ROBUST CSV PARSER ---
  function detectDelimiter(line) {
    const commaCount = (line.match(/,/g) || []).length;
    const tabCount = (line.match(/\t/g) || []).length;
    return tabCount > commaCount ? '\t' : ',';
  }

  function parseCsvRows(text) {
    const rows = [];
    const lines = text.split(/\r\n|\n|\r/);
    const firstNonEmpty = lines.find(l => String(l || '').trim() !== '') || '';
    const delimiter = detectDelimiter(firstNonEmpty);

    for (let i = 0; i < lines.length; i++) {
      const rawLine = lines[i];
      if (!rawLine || !String(rawLine).trim()) continue;

      const row = [];
      let curVal = "";
      let inQuote = false;

      for (let c = 0; c < rawLine.length; c++) {
        const char = rawLine[c];
        if (char === '"') {
          inQuote = !inQuote;
        } else if (char === delimiter && !inQuote) {
          row.push(curVal.trim());
          curVal = "";
        } else {
          curVal += char;
        }
      }
      row.push(curVal.trim());
      rows.push(row);
    }
    return rows;
  }

  const logicalRows = parseCsvRows(csvText);
  const findHeaderIndex = (headers) => {
    const idx = {};
    headers.forEach((h, i) => {
      const key = String(h ?? '')
        .replace(/^\uFEFF/, '')
        .trim()
        .toLowerCase()
        .replace(/\s+/g, '_')
        .replace(/[^a-z0-9_]/g, '');
      if (key) idx[key] = i;
    });
    return idx;
  };
  const firstRowIndex = logicalRows.findIndex(row => row.some(cell => String(cell ?? '').trim() !== ''));
  const firstRow = firstRowIndex >= 0 ? logicalRows[firstRowIndex] : [];
  const headerIndex = findHeaderIndex(firstRow);
  const hasHeaderMap = Boolean(headerIndex.device_id || headerIndex.test_id || headerIndex.date);
  const dataRows = hasHeaderMap ? logicalRows.slice(firstRowIndex + 1) : logicalRows;

  // --- DATE HELPERS (canonical key / parsing) ---
  const TZ = Session.getScriptTimeZone();

  function parseFlexibleDateTime(x) {
    const z0 = String(x ?? "").trim();
    if (!z0) return null;

    // normalize "yyyy-mm-dd | HH:mm" -> "yyyy-mm-dd HH:mm"
    const z = z0.replace(/\s*\|\s*/g, " ").replace(",", "");

    // yyyy-mm-dd HH:mm(:ss)
    let m = z.match(/^(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
    if (m) {
      const yy = +m[1], mm = +m[2] - 1, dd = +m[3];
      const HH = +(m[4] || 0), MI = +(m[5] || 0), SS = +(m[6] || 0);
      return new Date(yy, mm, dd, HH, MI, SS);
    }

    // mm/dd/yyyy (Sheets often shows this)
    m = z.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
    if (m) {
      const a = +m[1], b = +m[2], yy = +m[3];
      const HH = +(m[4] || 0), MI = +(m[5] || 0), SS = +(m[6] || 0);

      // Heuristic: if first part > 12 => dd/mm/yyyy, else treat as mm/dd/yyyy
      const dd = (a > 12) ? a : b;
      const mm = (a > 12) ? (b - 1) : (a - 1);

      return new Date(yy, mm, dd, HH, MI, SS);
    }

    // dd-mm-yyyy or dd/mm/yyyy
    m = z.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
    if (m) {
      const dd = +m[1], mm = +m[2] - 1, yy = +m[3];
      const HH = +(m[4] || 0), MI = +(m[5] || 0), SS = +(m[6] || 0);
      return new Date(yy, mm, dd, HH, MI, SS);
    }

    const d0 = new Date(z);
    return isNaN(d0.getTime()) ? null : d0;
  }

  function dateKey(v) {
    const d = (Object.prototype.toString.call(v) === "[object Date]" && !isNaN(v.getTime()))
      ? v
      : parseFlexibleDateTime(v);
    if (!d) return "";
    return Utilities.formatDate(d, TZ, "yyyy-MM-dd HH:mm");
  }

  // --- 4. NORMALIZE & MAP ---
  const normalizedRows = dataRows.map(row => {
    const obj = {};

    // ✅ These four always get Default if empty/missing
    obj["QC"] = false;
    obj["Client_ID"] = meta.Client_ID;
    obj["Farm_ID"] = meta.Farm_ID;
    obj["ProdBatch_ID"] = meta.ProdBatch_ID;
    obj["QCBatch_ID"] = meta.QCBatch_ID;

    const mapList = hasHeaderMap ? MAP_BY_HEADER : MAP_LEGACY;

    mapList.forEach(m => {
      const idx = hasHeaderMap ? headerIndex[m.csv] : m.logicIdx;
      let rawVal = (idx != null) ? row[idx] : undefined;
      if (typeof rawVal === 'string') rawVal = rawVal.replace(/^"|"$/g, '').trim();

      if (m.type === "device_sci") {
        if (!rawVal) {
          obj[m.head] = "";
        } else {
          const s = String(rawVal).trim();

          // If it's scientific notation OR huge integer, do NOT Number() unless safe
          if (/[eE]/.test(s)) {
            const num = Number(s);
            // preserve string if unsafe / precision loss
            if (!Number.isFinite(num) || (Math.abs(num) > Number.MAX_SAFE_INTEGER)) {
              obj[m.head] = s;
            } else {
              obj[m.head] = num.toLocaleString('fullwide', { useGrouping: false });
            }
          } else {
            // plain string digits (keep as-is)
            obj[m.head] = s;
          }
        }
      }
      else if (m.type === "string") {
        obj[m.head] = rawVal ? String(rawVal) : "";
      }
      else if (m.type === "date_any") {
        if (!rawVal) {
          obj[m.head] = "";
        } else {
          const d = parseFlexibleDateTime(rawVal);
          obj[m.head] = (d && !isNaN(d.getTime())) ? d : String(rawVal).trim();
        }
      }
      else if (m.type === "triplet") {
        if (m.auditHead) obj[m.auditHead] = rawVal || "";

        if (!rawVal) {
          obj[m.head] = "";
        } else {
          const tParts = String(rawVal).split(",");
          if (tParts.length >= 3) {
            const val = tParts[m.band];
            obj[m.head] = (val !== undefined && String(val).trim() !== "") ? parseInt(String(val).trim(), 10) : "";
          } else {
            obj[m.head] = "";
          }
        }
      }
    });

    return obj;
  });

  // --- 5. ROBUST DEDUPLICATION (Device + Test + DateKey) ---
  const lastRow = sh.getLastRow();
  const existingKeys = new Map();

  // compute indices from RGB_HEADERS (always correct)
  const devIdx = RGB_HEADERS.indexOf("Device_ID");
  const testIdx = RGB_HEADERS.indexOf("Test_ID");
  const dateIdx = RGB_HEADERS.indexOf("Test_date");

  const existingData = (lastRow > 1 && devIdx > -1 && testIdx > -1 && dateIdx > -1)
    ? sh.getRange(2, 1, lastRow - 1, RGB_HEADERS.length).getValues()
    : [];

  existingData.forEach((r, idx) => {
    const k = `${String(r[devIdx]).trim()}|${String(r[testIdx]).trim()}|${dateKey(r[dateIdx])}`;
    existingKeys.set(k, idx);
  });

  const fullData = existingData.slice();
  let matchedCount = 0;
  let appendedCount = 0;

  normalizedRows.forEach(rowObj => {
    const k = `${String(rowObj["Device_ID"]).trim()}|${String(rowObj["Test_ID"]).trim()}|${dateKey(rowObj["Test_date"])}`;
    const arr = RGB_HEADERS.map(h => Object.prototype.hasOwnProperty.call(rowObj, h) ? rowObj[h] : "");
    if (existingKeys.has(k)) {
      const idx = existingKeys.get(k);
      fullData[idx] = arr;
      matchedCount++;
    } else {
      fullData.push(arr);
      existingKeys.set(k, fullData.length - 1);
      appendedCount++;
    }
  });

  // --- 7. RECALCULATE & FORMAT ---
  const newLastRow = fullData.length + 1;
  if (newLastRow < 2) {
    return { ok: true, total_in_csv: normalizedRows.length, matched_existing: matchedCount, appended: 0 };
  }

  const fullRange = sh.getRange(2, 1, fullData.length, RGB_HEADERS.length);
  const hIdx = {};
  RGB_HEADERS.forEach((h, i) => hIdx[h] = i);

  const METRICS = [
    { abs: "NH4N_Abs", t: "NH4N_S1_B_T", c: "NH4N_S1_B_C" },
    { abs: "B_Abs", t: "B_S1_B_T", c: "B_S1_B_C" },
    { abs: "Cu_Abs", t: "Cu_S2_R_T", c: "Cu_S2_R_C" },
    { abs: "Fe_Abs", t: "Fe_S2_G_T", c: "Fe_S2_G_C" },
    { abs: "Mn_Abs", t: "Mn_S2_G_T", c: "Mn_S2_G_C" },
    { abs: "NO3N_Abs", t: "NO3N_S1_G_T", c: "NO3N_S1_G_C" },
    { abs: "OC_Abs", t: "OC_S1_G_T", c: "OC_S1_G_C" },
    { abs: "P_Abs", t: "P_S1_B_T", c: "P_S1_B_C" },
    { abs: "K_Abs", t: "K_S2_B_T", c: "K_S2_B_C" },
    { abs: "S_Abs", t: "S_S1_B_T", c: "S_S1_B_C" },
    { abs: "ZnCu_Abs", t: "ZnCu_S2_R_T", c: "ZnCu_S2_R_C" }
  ];

  fullData.forEach(row => {
    METRICS.forEach(m => {
      const t = row[hIdx[m.t]];
      const c = row[hIdx[m.c]];
      if (typeof t === 'number' && typeof c === 'number' && c !== 0) {
        row[hIdx[m.abs]] = parseFloat((1 - (t / c)).toFixed(3));
      } else {
        row[hIdx[m.abs]] = "";
      }
    });

    ["EC", "pH"].forEach(type => {
      const rawHead = type === "EC" ? "EC_S0_R_T" : "pH_S0_R_T";
      const valHead = type === "EC" ? "EC_Val" : "pH_Val";
      const r = row[hIdx[rawHead]];
      if (typeof r === 'number') {
        row[hIdx[valHead]] = parseFloat((r / 100).toFixed(2));
      } else {
        row[hIdx[valHead]] = "";
      }
    });
  });

  // QC is UI-only tick-toggle; keep it FALSE in the sheet always (checkbox-safe).
  if (hIdx["QC"] !== undefined) {
    fullData.forEach(r => { r[hIdx["QC"]] = false; });
  }

  fullRange.setValues(fullData);

  // Ensure QC column is a checkbox column (toggle only)
  const qcColNum = hIdx["QC"] + 1;
  if (qcColNum > 0) {
    sh.getRange(2, qcColNum, sh.getLastRow() - 1, 1).insertCheckboxes();
  }

  // Re-format Date column to strict format
  const dateColNum = hIdx["Test_date"] + 1;
  sh.getRange(2, dateColNum, fullData.length, 1).setNumberFormat("yyyy-mm-dd | HH:mm");

  return {
    ok: true,
    total_in_csv: normalizedRows.length,
    matched_existing: matchedCount,
    appended: appendedCount
  };
}





function test_srvr_CreateRGBData() {
  // Mock CSV Data
  // Fixed: Added correct number of commas (7) in the empty gaps to represent 6 empty fields.
  // Fixed: Added \n between rows.

  const mockCsv = `device_id,test_id,date,Amnm_n,Amnm_n_cal,Brn,Brn_cal,Cpr,Cpr_cal,Ec,Ec_cal,Irn,Irn_cal,Mgns,Mgns_cal,Ntrt_n,Ntrt_n_cal,Org_crbn,Org_crbn_cal,Ph,Ph_cal,Phprs,Phprs_cal,Potsm,Potsm_cal,Slpr,Slpr_cal,Znc,Znc_cal,bn,
862211073285801,40971,27-11-2025, 24, 1576, 7047, 25, 1642, 7341,,,,,,, 3308, 41, 0, 6602, 84, 0, 0, 0, 0, 53248, 17987, 15543, 9, 3278, 393, 9, 3701, 456, 8, 3249, 392, 9, 3701, 456, 6, 3686, 511, 6, 4236, 601, 6, 3414, 468, 6, 4236, 601, 600, 0, 0, 14162, 17923, 19115, 18, 1264, 5340, 25, 1642, 7341, 25, 1325, 4709, 26, 1382, 4916, 18, 1233, 5442, 25, 1642, 7341, 2783, 34, 0, 6602, 84, 0,
862211073286973,40988,28-11-2025, 32, 2259, 9224, 32, 2266, 9259, 23, 1577, 6297, 32, 2266, 9259, 7109, 98, 0, 9208, 137, 0, 0, 0, 0, 32768, 17874, 29623, 10, 5943, 810, 10, 7828, 1114, 10, 7408, 1050, 10, 7828, 1114, 5, 3719, 462, 3, 5305, 712, 4, 4026, 520, 3, 5305, 712, 595, 0, 0, 14153, 17883, 5461, 26, 1888, 7463, 32, 2266, 9259, 56, 3092, 11087, 60, 3290, 11859, 32, 2233, 9129, 32, 2266, 9259, 6217, 79, 0, 9208, 137, 0,`;

  const payload = {
    csvText: mockCsv,
    meta: {
      Client_ID: "Client_001",
      Farm_ID: "Farm_Alpha",
      ProdBatch_ID: "Batch_2025_A",
      QCBatch_ID: "QC_Nov_25"
    }
  };

  try {
    const result = srvr_CreateRGBData_ImportCSV_appendtoRGB_dedup(payload);
    Logger.log("Success! Result: " + JSON.stringify(result));
  } catch (e) {
    Logger.log("Error: " + e.message + "\nStack: " + e.stack);
  }
}



function debug_TestRunner() {
  const result = getInitialData();
  console.log("Result Type: " + typeof result);
  if (result === null) {
    console.error("Result is NULL - Code is failing silently");
  } else if (result.error) {
    console.error("Result Error: " + result.error);
  } else {
    console.log("SUCCESS! Got data keys: " + Object.keys(result).join(", "));
  }
}

function ping() {
  return { ok: true, version: APP_VERSION, buildTime: BUILD_TIMESTAMP, now: new Date().toISOString() };
}





//========================================================================================================================================================
//========================================================================================================================================================
//========================================================================================================================================================
//========================================================================================================================================================
//========================================================================================================================================================


/**
 * UI fetch for RGB/Abs module tables.
 * Returns rows as objects keyed by sheet headers (so client can render without recomputing).
 */
function server_GetRGBDataForUI() {
  var SHEET_NAME = 'RGB_Data';
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) return { ok: true, headers: [], rows: [] };

  var lastRow = sh.getLastRow();
  var lastCol = sh.getLastColumn();
  if (lastRow < 2 || lastCol < 1) {
    var headers0 = lastCol >= 1 ? sh.getRange(1, 1, 1, lastCol).getValues()[0] : [];
    return { ok: true, headers: headers0, rows: [] };
  }

  var headers = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(String);
  var values = sh.getRange(2, 1, lastRow - 1, lastCol).getValues();

  var rows = values.map(function (r) {
    var obj = {};
    for (var c = 0; c < headers.length; c++) obj[headers[c]] = r[c];
    return obj;
  });

  return { ok: true, headers: headers, rows: rows };
}


function debugGetInitialData() {
  const res = getInitialData();
  Logger.log('debugGetInitialData result=%s', JSON.stringify(res));
  return res;
}


/**
 * One-time QC_Data header auto-fix + verification.
 *
 * What it does:
 * 1) Ensures a sheet named "QC_Data" exists
 * 2) Reads row-1 headers
 * 3) Rebuilds headers to match your canonical order:
 *    QC, Client_ID, Farm_ID, ProdBatch_ID, QCBatch_ID, Device_ID, Test_ID, Test_date, + metric labels
 * 4) Preserves ANY extra (unknown) columns by appending them at the end (so you don't lose data)
 * 5) Verifies and returns a detailed report (missing/extra/duplicates)
 *
 * Safe: only edits row 1. Does NOT touch data rows.
 */
function oneTime_QCData_AutofixHeaders_AndCheck() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const SHEET_NAME = 'QC_Data';

  // ---- 1) Get / create sheet
  let sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) sh = ss.insertSheet(SHEET_NAME);

  // ---- 2) Define canonical headers
  const BASE_HEADERS = [
    'QC',
    'Client_ID',
    'Farm_ID',
    'ProdBatch_ID',
    'QCBatch_ID',
    'Device_ID',
    'Test_ID',
    'Test_date',
  ];

  // Metrics:
  // Preferred source: global METRIC_COLS_FLAT (from your frontend contract)
  // Fallback: if not available here, use a minimal default list.
  const metricLabels = (function getMetricLabels_() {
    try {
      // If you also defined METRIC_COLS_FLAT in Apps Script (recommended), use it.
      if (typeof METRIC_COLS_FLAT !== 'undefined' && Array.isArray(METRIC_COLS_FLAT)) {
        return METRIC_COLS_FLAT
          .map(c => (c && (c.label || c.n || c.k)) ? String(c.label || c.n || c.k) : '')
          .filter(Boolean);
      }
    } catch (e) { }
    // Default fallback (edit if your metric list differs)
    return ['NH4N', 'B', 'Cu', 'EC', 'Fe', 'Mn', 'NO3N', 'OC', 'pH', 'P', 'K', 'S', 'ZnCu'];
  })();

  const CANONICAL = BASE_HEADERS.concat(metricLabels);

  // ---- 3) Read current header row
  const lastCol = Math.max(1, sh.getLastColumn());
  const currentRow1 = sh.getRange(1, 1, 1, lastCol).getValues()[0] || [];
  const currentHeaders = currentRow1.map(h => String(h ?? '').trim()).filter(h => h !== '');

  // If sheet is empty (no real headers), treat as empty.
  const currentSet = new Set(currentHeaders);

  // ---- 4) Preserve unknown/existing extra columns (append at end)
  const extras = currentHeaders.filter(h => !CANONICAL.includes(h));

  // Also preserve columns that exist beyond getLastColumn() but are blank in row1? ignore.
  const finalHeaders = CANONICAL.concat(extras);

  // ---- 5) Write header row (row 1 only)
  sh.getRange(1, 1, 1, finalHeaders.length).setValues([finalHeaders]);

  // If the old header row was longer, clear the remaining old header cells (row 1 only)
  if (lastCol > finalHeaders.length) {
    sh.getRange(1, finalHeaders.length + 1, 1, lastCol - finalHeaders.length).clearContent();
  }

  // ---- 6) Verification report
  const duplicates = (function findDuplicates_(arr) {
    const seen = new Set();
    const dups = new Set();
    arr.forEach(x => {
      if (seen.has(x)) dups.add(x);
      else seen.add(x);
    });
    return Array.from(dups);
  })(finalHeaders);

  const missing = CANONICAL.filter(h => !finalHeaders.includes(h)); // should be none
  const addedExtras = extras.slice();
  const unchanged = currentHeaders.join('||') === finalHeaders.join('||');

  const report = {
    sheet: SHEET_NAME,
    wroteHeaderCount: finalHeaders.length,
    canonicalCount: CANONICAL.length,
    hadHeaders: currentHeaders.length,
    unchanged,
    duplicates,
    missingCanonical: missing,
    extraPreserved: addedExtras,
    finalHeaders,
  };

  Logger.log(JSON.stringify(report, null, 2));
  return report;
}


function srvr_BackfillDefaultMetaFields_RGB_QC() {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const targets = ["RGB_Data", "QC_Data"];

    const def = (v) => {
      const s = String(v ?? "").trim();
      return s ? s : "Default";
    };

    targets.forEach(name => {
      const sh = ss.getSheetByName(name);
      if (!sh) return;

      const lastRow = sh.getLastRow();
      const lastCol = sh.getLastColumn();
      if (lastRow < 2 || lastCol < 1) return;

      const hdr = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(h => String(h ?? "").trim());
      const idx = {};
      hdr.forEach((h, i) => { if (h) idx[h] = i; });

      const needed = ["Client_ID", "Farm_ID", "ProdBatch_ID", "QCBatch_ID"];
      const present = needed.filter(h => idx[h] != null);
      if (!present.length) return;

      const data = sh.getRange(2, 1, lastRow - 1, lastCol).getValues();
      let changed = 0;

      for (let r = 0; r < data.length; r++) {
        present.forEach(h => {
          const c = idx[h];
          const cur = data[r][c];
          const next = def(cur);
          if (String(cur ?? "").trim() !== next) {
            data[r][c] = next;
            changed++;
          }
        });
      }

      if (changed) {
        sh.getRange(2, 1, data.length, lastCol).setValues(data);
      }
    });

    return { ok: true };
  } finally {
    lock.releaseLock();
  }
}



function _normHdrKey_(h) {
  return String(h ?? "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function _buildHdrIndex_(hdrRow) {
  const idx = {};
  hdrRow.forEach((h, i) => {
    const k = _normHdrKey_(h);
    if (k) idx[k] = i;
  });
  return idx;
}

// Parse many date formats into a Date object (script TZ), else null
function _parseAnyDate_(v) {
  if (v == null || v === "") return null;

  if (Object.prototype.toString.call(v) === "[object Date]" && !isNaN(v.getTime())) {
    return v;
  }

  const s = String(v).trim();
  if (!s) return null;

  // normalize pipe
  const z = s.replace(/\s*\|\s*/g, " ").replace(",", "");

  // yyyy-mm-dd HH:mm[:ss]
  let m = z.match(/^(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m) {
    const yy = +m[1], mm = +m[2] - 1, dd = +m[3];
    const HH = +(m[4] || 0), MI = +(m[5] || 0), SS = +(m[6] || 0);
    return new Date(yy, mm, dd, HH, MI, SS);
  }

  // mm/dd/yyyy [HH:mm[:ss]]  (common in Sheets display)
  m = z.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m) {
    const mm = +m[1] - 1, dd = +m[2], yy = +m[3];
    const HH = +(m[4] || 0), MI = +(m[5] || 0), SS = +(m[6] || 0);
    return new Date(yy, mm, dd, HH, MI, SS);
  }

  // dd/mm/yyyy [HH:mm[:ss]] (your UI sometimes shows 28/11/2025)
  m = z.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m) {
    // ambiguity: if first part > 12 treat as dd/mm
    const a = +m[1], b = +m[2], yy = +m[3];
    const dd = (a > 12) ? a : b;
    const mm = (a > 12) ? (b - 1) : (a - 1);
    const HH = +(m[4] || 0), MI = +(m[5] || 0), SS = +(m[6] || 0);
    return new Date(yy, mm, dd, HH, MI, SS);
  }

  const d0 = new Date(z);
  return isNaN(d0.getTime()) ? null : d0;
}

function _dateKey_(v) {
  const d = _parseAnyDate_(v);
  if (!d) return "";
  return Utilities.formatDate(d, Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm");
}

function _moveKey_(did, tid, dt) {
  return `${String(did ?? "").trim()}__${String(tid ?? "").trim()}__${_dateKey_(dt)}`;
}



//-------------------------------------- Start of QC Batch and Prod Batch assignment in the UI -------------------------------------------

/**************************************
 * MASTER SHEETS: QC_Batch, Prod_Batch
 **************************************/

function _normHeaderKey_(h) {
  return String(h || '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/_/g, '');
}

function _ensureSheetWithHeaders_(ss, name, headers) {
  let sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);
  const existing = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0] || [];
  const existingNorm = existing.map(_normHeaderKey_);
  const wantedNorm = headers.map(_normHeaderKey_);

  // If header row doesn't match, reset header row only (do not destroy data blindly).
  // If sheet is empty, we set headers.
  const isEmpty = sh.getLastRow() === 0 || (sh.getLastRow() === 1 && existing.join('').trim() === '');
  if (isEmpty) {
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sh;
  }

  // If columns mismatch, enforce headers row but keep data under current columns as-is.
  // (User can realign manually if they created a different structure.)
  const mismatch = wantedNorm.some((k, i) => existingNorm[i] !== k);
  if (mismatch) {
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
  }
  return sh;
}

function _readSheetObjects_(sh) {
  if (!sh) return [];
  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2 || lastCol < 1) return [];

  const values = sh.getRange(1, 1, lastRow, lastCol).getValues();
  const headers = values[0].map(h => String(h || '').trim());
  const rows = values.slice(1);

  const out = [];
  for (const r of rows) {
    // skip fully empty rows
    const nonEmpty = r.some(v => String(v ?? '').trim() !== '');
    if (!nonEmpty) continue;

    const obj = {};
    for (let c = 0; c < headers.length; c++) {
      obj[headers[c]] = r[c];
    }
    out.push(obj);
  }
  return out;
}

function _writeSheetObjects_(sh, headers, objects) {
  if (!sh) return;
  const data = Array.isArray(objects) ? objects : [];
  const out = data.map(o => headers.map(h => (o && o[h] !== undefined ? o[h] : '')));

  // Clear old rows (keep header)
  const lastRow = sh.getLastRow();
  if (lastRow > 1) {
    sh.getRange(2, 1, lastRow - 1, Math.max(1, sh.getLastColumn())).clearContent();
  }

  if (out.length) {
    sh.getRange(2, 1, out.length, headers.length).setValues(out);
  }
}

// =============================
// MODULE 3: QC/PROD MASTER DATA
// =============================
/** QC_Batch headers (as given by you) */
function _qcBatchHeaders_() {
  return ['QCBatch_ID','PrepDate_QCBatch','QCBatch_recipe','QCBatch_totalQty','QCBatch_madeby','Notes'];
}

/** Prod_Batch headers (as given by you) */
function _prodBatchHeaders_() {
  return ['ProdBatch_ID','ProdBatch_totaldevices','Manufacturer_name','Manufactured_fromDate','Manufactured_tillDate','Delivery_date','PO_number','Notes'];
}

/** Read QC_Batch master table */
function srvrReadQCBatchMaster() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = _ensureSheetWithHeaders_(ss, 'QC_Batch', _qcBatchHeaders_());
  return _readSheetObjects_(sh);
}

/** Save QC_Batch master table */
function srvrSaveQCBatchMaster(rows) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = _ensureSheetWithHeaders_(ss, 'QC_Batch', _qcBatchHeaders_());

  const safe = Array.isArray(rows) ? rows : [];
  // Normalize IDs; do not allow blank IDs to be saved
  const cleaned = safe
    .map(r => (r && typeof r === 'object') ? r : {})
    .map(r => {
      const o = {};
      _qcBatchHeaders_().forEach(h => o[h] = (r[h] !== undefined ? r[h] : ''));
      o.QCBatch_ID = String(o.QCBatch_ID || '').trim();
      return o;
    })
    .filter(r => r.QCBatch_ID !== '');

  _writeSheetObjects_(sh, _qcBatchHeaders_(), cleaned);
  return { ok: true, count: cleaned.length };
}

/** Read Prod_Batch master table */
function srvrReadProdBatchMaster() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = _ensureSheetWithHeaders_(ss, 'Prod_Batch', _prodBatchHeaders_());
  return _readSheetObjects_(sh);
}

/** Save Prod_Batch master table */
function srvrSaveProdBatchMaster(rows) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = _ensureSheetWithHeaders_(ss, 'Prod_Batch', _prodBatchHeaders_());

  const safe = Array.isArray(rows) ? rows : [];
  const cleaned = safe
    .map(r => (r && typeof r === 'object') ? r : {})
    .map(r => {
      const o = {};
      _prodBatchHeaders_().forEach(h => o[h] = (r[h] !== undefined ? r[h] : ''));
      o.ProdBatch_ID = String(o.ProdBatch_ID || '').trim();
      return o;
    })
    .filter(r => r.ProdBatch_ID !== '');

  _writeSheetObjects_(sh, _prodBatchHeaders_(), cleaned);
  return { ok: true, count: cleaned.length };
}


/********************************************
 * Update RGB_Data row with Batch assignments
 ********************************************/

function _normalizeDateKey_(v) {
  if (!v) return '';
  const tz = Session.getScriptTimeZone() || 'GMT';
  if (v instanceof Date && !isNaN(v.getTime())) {
    return Utilities.formatDate(v, tz, 'yyyy-MM-dd HH:mm');
  }
  const s0 = String(v).trim();
  if (!s0) return '';
  const s = s0.includes('|') ? s0.replace(/\s*\|\s*/g, ' ') : s0;

  // Try to parse; if parse works, standardize to yyyy-MM-dd HH:mm
  const d = new Date(s);
  if (!isNaN(d.getTime())) {
    return Utilities.formatDate(d, tz, 'yyyy-MM-dd HH:mm');
  }

  // Fallback: if it begins with yyyy-mm-dd, keep that part
  const m = s0.match(/^(\d{4}-\d{2}-\d{2})/);
  if (m) return m[1];

  return s0;
}

/**
 * Update ProdBatch_ID and/or QCBatch_ID for a specific RGB_Data row
 * Match key: Device_ID + Test_ID + Test_date (minute precision)
 *
 * payload:
 * {
 *   deviceId, testId, testDate,
 *   prodBatchId, qcBatchId
 * }
 */
function srvrSetRgbBatchFields(payload) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('RGB_Data');
  if (!sh) throw new Error('Missing required sheet: RGB_Data');

  const p = payload || {};
  const deviceId = String(p.deviceId || '').trim();
  const testId   = String(p.testId || '').trim();
  const testDate = _normalizeDateKey_(p.testDate || '');

  const prodBatchId = (p.prodBatchId === undefined) ? null : String(p.prodBatchId || '').trim();
  const qcBatchId   = (p.qcBatchId === undefined) ? null : String(p.qcBatchId || '').trim();

  if (!deviceId || !testId) {
    throw new Error('srvrSetRgbBatchFields: deviceId and testId are required');
  }

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2) throw new Error('RGB_Data has no data rows');

  const header = sh.getRange(1, 1, 1, lastCol).getValues()[0];
  const hmap = {};
  header.forEach((h, idx) => { hmap[_normHeaderKey_(h)] = idx + 1; });

  const colDevice = hmap['deviceid'] || hmap['device_id'];
  const colTest   = hmap['testid']   || hmap['test_id'];
  const colDate   = hmap['testdate'] || hmap['test_date'];
  const colProd   = hmap['prodbatchid'] || hmap['prodbatch_id'];
  const colQC     = hmap['qcbatchid']   || hmap['qcbatch_id'];

  if (!colDevice || !colTest) throw new Error('RGB_Data missing Device_ID/Test_ID columns');
  if (!colProd || !colQC)     throw new Error('RGB_Data missing ProdBatch_ID/QCBatch_ID columns');

  const range = sh.getRange(2, 1, lastRow - 1, lastCol);
  const values = range.getValues();

  let foundRowOffset = -1;

  // Primary match: device + test + normalized date (if date provided)
  for (let i = 0; i < values.length; i++) {
    const r = values[i];
    const d = String(r[colDevice - 1] || '').trim();
    const t = String(r[colTest - 1] || '').trim();

    if (d !== deviceId || t !== testId) continue;

    if (testDate) {
      const rDate = _normalizeDateKey_(r[(colDate || 0) - 1]);
      if (rDate === testDate) {
        foundRowOffset = i;
        break;
      }
    } else {
      // no testDate provided -> first match
      foundRowOffset = i;
      break;
    }
  }

  // Fallback match if exact date not found: device + test only (rare)
  if (foundRowOffset < 0 && testDate) {
    for (let i = 0; i < values.length; i++) {
      const r = values[i];
      const d = String(r[colDevice - 1] || '').trim();
      const t = String(r[colTest - 1] || '').trim();
      if (d === deviceId && t === testId) {
        foundRowOffset = i;
        break;
      }
    }
  }

  if (foundRowOffset < 0) {
    throw new Error(`RGB row not found for Device_ID=${deviceId}, Test_ID=${testId}, Test_date=${testDate || '(any)'}`);
  }

  const sheetRow = foundRowOffset + 2;

  if (prodBatchId !== null) sh.getRange(sheetRow, colProd).setValue(prodBatchId || 'Default');
  if (qcBatchId !== null)   sh.getRange(sheetRow, colQC).setValue(qcBatchId || 'Default');

  return { ok: true, row: sheetRow, prodBatchId: prodBatchId, qcBatchId: qcBatchId };
}

/**
 * Master lists source of truth:
 *   - QC_Batch sheet, header: QCBatch_ID
 *   - Prod_Batch sheet, header: ProdBatch_ID
 *
 * Returns:
 *   { qcBatchIds: ['Default', ...], prodBatchIds: ['Default', ...], __status:'OK' }
 */
function srvr_getMasterLists() {
  const out = { qcBatchIds: ['Default'], prodBatchIds: ['Default'], __status: 'OK' };

  try {
    const cache = CacheService.getScriptCache();
    const cached = cache.get('MASTER_LISTS_V1');
    if (cached) {
      const obj = JSON.parse(cached);
      if (obj && Array.isArray(obj.qcBatchIds) && Array.isArray(obj.prodBatchIds)) return obj;
    }

    const ss = SpreadsheetApp.getActive();
    if (!ss) throw new Error('No active spreadsheet');

    out.qcBatchIds = readIdListFromSheet_(ss, 'QC_Batch', 'QCBatch_ID');
    out.prodBatchIds = readIdListFromSheet_(ss, 'Prod_Batch', 'ProdBatch_ID');

    // ensure Default is present + sorted with Default first
    out.qcBatchIds = normalizeDefaultFirst_(out.qcBatchIds);
    out.prodBatchIds = normalizeDefaultFirst_(out.prodBatchIds);

    cache.put('MASTER_LISTS_V1', JSON.stringify(out), 300); // 5 minutes
    return out;

  } catch (e) {
    Logger.log('srvr_getMasterLists error: ' + e.message);
    out.__status = 'ERROR';
    out.__error = e.message;
    return out;
  }
}

/** Helper: read unique IDs from sheet by header (case-insensitive match) */
function readIdListFromSheet_(ss, sheetName, headerName) {
  const sh = ss.getSheetByName(sheetName);
  if (!sh) return ['Default'];

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2 || lastCol < 1) return ['Default'];

  const values = sh.getRange(1, 1, lastRow, lastCol).getValues();
  const headers = (values[0] || []).map(h => String(h ?? '').trim());

  const want = String(headerName).trim().toLowerCase();
  const idx = headers.findIndex(h => String(h || '').trim().toLowerCase() === want);
  if (idx === -1) return ['Default'];

  const set = new Set();
  for (let i = 1; i < values.length; i++) {
    const v = String(values[i][idx] || '').trim();
    if (v) set.add(v);
  }
  set.add('Default');
  return Array.from(set);
}

function normalizeDefaultFirst_(arr) {
  const set = new Set((Array.isArray(arr) ? arr : []).map(v => String(v || '').trim()).filter(Boolean));
  set.add('Default');
  const out = Array.from(set);
  out.sort((a, b) => (a === 'Default' ? -1 : b === 'Default' ? 1 : a.localeCompare(b)));
  return out;
}

function getQCBatchOptions() {
  const res = srvr_getMasterLists();
  return (res && Array.isArray(res.qcBatchIds) && res.qcBatchIds.length) ? res.qcBatchIds : ['Default'];
}

function getProdBatchOptions() {
  const res = srvr_getMasterLists();
  return (res && Array.isArray(res.prodBatchIds) && res.prodBatchIds.length) ? res.prodBatchIds : ['Default'];
}

function srvr_getMasterLists() {
  const CACHE_KEY = 'MASTER_LISTS_v1';
  const CACHE_TTL_SEC = 180; // 3 minutes

  // 1) cache
  try {
    const cache = CacheService.getScriptCache();
    const cached = cache.get(CACHE_KEY);
    if (cached) {
      const obj = JSON.parse(cached);
      if (obj && typeof obj === 'object') return obj;
    }
  } catch (e) {}

  // 2) build
  const out = {
    qcBatchIds: ['Default'],
    prodBatchIds: ['Default']
  };

  const ss = SpreadsheetApp.getActive();

  // QC_Batch
  try {
    const shQC = ss.getSheetByName('QC_Batch');
    if (shQC) {
      const v = shQC.getDataRange().getValues();
      if (v && v.length >= 2) {
        const headers = v[0].map(h => String(h || '').trim());
        const idx = headers.indexOf('QCBatch_ID');
        if (idx !== -1) {
          const set = new Set(['Default']);
          for (let i = 1; i < v.length; i++) {
            const id = String(v[i][idx] ?? '').trim();
            if (id) set.add(id);
          }
          out.qcBatchIds = Array.from(set).sort((a,b)=>(a==='Default'?-1:b==='Default'?1:a.localeCompare(b)));
        }
      }
    }
  } catch (e) {
    // keep defaults
  }

  // Prod_Batch
  try {
    const shPB = ss.getSheetByName('Prod_Batch');
    if (shPB) {
      const v = shPB.getDataRange().getValues();
      if (v && v.length >= 2) {
        const headers = v[0].map(h => String(h || '').trim());
        const idx = headers.indexOf('ProdBatch_ID');
        if (idx !== -1) {
          const set = new Set(['Default']);
          for (let i = 1; i < v.length; i++) {
            const id = String(v[i][idx] ?? '').trim();
            if (id) set.add(id);
          }
          out.prodBatchIds = Array.from(set).sort((a,b)=>(a==='Default'?-1:b==='Default'?1:a.localeCompare(b)));
        }
      }
    }
  } catch (e) {
    // keep defaults
  }

  // 3) cache
  try {
    CacheService.getScriptCache().put(CACHE_KEY, JSON.stringify(out), CACHE_TTL_SEC);
  } catch (e) {}

  return out;
}


function clearMasterListsCache() {
  CacheService.getScriptCache().remove('MASTER_LISTS_v1');
}




//-------------------------------------- End of QC Batch and Prod Batch assignment in the UI -------------------------------------------

/**
 * =============================
 * MODULE 6: INVENTORY MANAGER
 * =============================
 */

function inventorySheetDefs_() {
  return {
    constitution: {
      name: 'Inventory_Device_Constitution',
      headers: ['Category','Item Class','Item','Unit','Units/Device','Cost (Rs)/Unit','Version','Effective Date','Cost/Device'],
      fields: ['category','itemClass','item','unit','unitsPerDevice','costPerUnit','version','effectiveDate','costPerDevice']
    },
    parts: {
      name: 'Inventory_Parts_Stock',
      headers: ['Category','Item Class','Item','Unit','In-stock Qty','Cost (Rs)/Unit','Movement Type','Date of Movement','Delivery_date','PO_number','Confirmed by','Issued to','Request ID'],
      fields: ['category','itemClass','item','unit','qty','costPerUnit','movement','date','deliveryDate','poNumber','confirmedBy','issuedTo','requestId']
    },
    built: {
      name: 'Inventory_Built_Units',
      headers: ['Serial','Device_ID','Count','Date_of_manufacture','Date_of_sale','Sold_or_issued_to','Movement','Confirmed','Request_ID'],
      fields: ['serial','deviceId','count','mfgDate','saleDate','soldTo','movement','confirmed','requestId']
    },
    liquidation: {
      name: 'Inventory_Liquidation',
      headers: ['Request_ID','Item','Issue_or_sale','Issued_or_sold_to','Units_before','Units_after','Units_issued','Date_issued','Issue_acknowledged','Evidence_PDF','Status'],
      fields: ['requestId','item','action','issuedTo','unitsBefore','unitsAfter','unitsIssued','date','acknowledged','evidence','status']
    },
    clients: {
      name: 'Inventory_ClientList',
      headers: ['Client type','Client name','Client address','Client contact','Client email','Item','GSTIN'],
      fields: ['clientType','clientName','clientAddress','clientContact','clientEmail','item','gstin']
    },
    approvals: {
      name: 'Inventory_Approvals',
      headers: ['Request_ID','Requested_by','TAT_days','Due_date','Status','Approver','Item'],
      fields: ['requestId','requestedBy','tatDays','dueDate','status','approver','item']
    },
    refill: {
      name: 'Inventory_Refill_Batch',
      headers: ['Refill Box ID','Lot size','Refill lot ID','Manufacturer name','Manufacture date','Expiry Date','Delivery_date','PO_number','Notes'],
      fields: ['refillId','lotSize','refillLotId','manufacturerName','manufactureDate','expiryDate','deliveryDate','poNumber','notes']
    }
  };
}

function ensureInventorySheets_(ss, missingArr) {
  const defs = inventorySheetDefs_();
  Object.values(defs).forEach(def => {
    let sh = ss.getSheetByName(def.name);
    if (!sh) {
      sh = ss.insertSheet(def.name);
      if (Array.isArray(missingArr)) missingArr.push(def.name);
      sh.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
      sh.setFrozenRows(1);
    } else {
      const existing = sh.getRange(1, 1, 1, sh.getLastColumn() || def.headers.length).getValues()[0];
      const normalized = existing.map(h => String(h || '').trim());
      const needHeader = def.headers.some((h, i) => normalized[i] !== h);
      if (needHeader) {
        sh.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
        sh.setFrozenRows(1);
      }
    }
  });
}

function getInventoryData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) throw new Error('No active spreadsheet');
  ensureInventorySheets_(ss);
  const defs = inventorySheetDefs_();

  const parseSheetFloat = (value) => {
    if (value === '' || value === null || value === undefined) return '';
    const num = Number(value);
    if (!Number.isFinite(num)) return value;
    return num.toFixed(2);
  };

  const parseSheetDateTime = (value) => {
    if (!value) return '';
    if (Object.prototype.toString.call(value) === '[object Date]') {
      const year = value.getFullYear();
      const month = String(value.getMonth() + 1).padStart(2, '0');
      const day = String(value.getDate()).padStart(2, '0');
      const hours = String(value.getHours()).padStart(2, '0');
      const minutes = String(value.getMinutes()).padStart(2, '0');
      return `${day}-${month}-${year};${hours}:${minutes}`;
    }
    return String(value);
  };

  const readAndMap = (def, mapFn) => {
    const rows = readSheetAsObjects(ss, def.name, []);
    return rows.map(mapFn);
  };

  return {
    constitution: readAndMap(defs.constitution, (r) => ({
      category: r.Category || '',
      itemClass: r['Item Class'] || '',
      item: r.Item || '',
      unit: r.Unit || '',
      unitsPerDevice: parseSheetFloat(r['Units/Device'] || ''),
      costPerUnit: parseSheetFloat(r['Cost (Rs)/Unit'] || ''),
      version: r.Version || '',
      effectiveDate: r['Effective Date'] || '',
      costPerDevice: parseSheetFloat(r['Cost/Device'] || '')
    })),
    parts: readAndMap(defs.parts, (r) => ({
      category: r.Category || '',
      itemClass: r['Item Class'] || '',
      item: r.Item || '',
      unit: r.Unit || '',
      qty: parseSheetFloat(r['In-stock Qty'] || ''),
      costPerUnit: parseSheetFloat(r['Cost (Rs)/Unit'] || ''),
      movement: r['Movement Type'] || '',
      date: parseSheetDateTime(r['Date of Movement'] || ''),
      deliveryDate: parseSheetDateTime(r.Delivery_date || ''),
      poNumber: r.PO_number || '',
      confirmedBy: r['Confirmed by'] || '',
      issuedTo: r['Issued to'] || '',
      requestId: r['Request ID'] || ''
    })),
    built: readAndMap(defs.built, (r) => ({
      serial: r.Serial || '',
      deviceId: r.Device_ID || '',
      count: r.Count || '',
      mfgDate: r.Date_of_manufacture || '',
      saleDate: r.Date_of_sale || '',
      soldTo: r.Sold_or_issued_to || '',
      movement: r.Movement || '',
      confirmed: String(r.Confirmed || '').toLowerCase() === 'true',
      requestId: r.Request_ID || ''
    })),
    liquidation: readAndMap(defs.liquidation, (r) => ({
      requestId: r.Request_ID || '',
      item: r.Item || '',
      action: r.Issue_or_sale || '',
      issuedTo: r.Issued_or_sold_to || '',
      unitsBefore: r.Units_before || '',
      unitsAfter: r.Units_after || '',
      unitsIssued: r.Units_issued || '',
      date: r.Date_issued || '',
      acknowledged: String(r.Issue_acknowledged || '').toLowerCase() === 'true',
      evidence: r.Evidence_PDF || '',
      status: r.Status || ''
    })),
    clients: readAndMap(defs.clients, (r) => ({
      clientType: r['Client type'] || '',
      clientName: r['Client name'] || '',
      clientAddress: r['Client address'] || '',
      clientContact: r['Client contact'] || '',
      clientEmail: r['Client email'] || '',
      item: r.Item || '',
      gstin: r.GSTIN || ''
    })),
    approvals: readAndMap(defs.approvals, (r) => ({
      requestId: r.Request_ID || '',
      requestedBy: r.Requested_by || '',
      tatDays: r.TAT_days || '',
      dueDate: r.Due_date || '',
      status: r.Status || '',
      approver: r.Approver || '',
      item: r.Item || ''
    })),
    refill: readAndMap(defs.refill, (r) => ({
      refillId: r['Refill Box ID'] || '',
      lotSize: parseSheetFloat(r['Lot size'] || ''),
      refillLotId: r['Refill lot ID'] || '',
      manufacturerName: r['Manufacturer name'] || '',
      manufactureDate: parseSheetDateTime(r['Manufacture date'] || ''),
      expiryDate: parseSheetDateTime(r['Expiry Date'] || ''),
      deliveryDate: parseSheetDateTime(r.Delivery_date || ''),
      poNumber: r.PO_number || '',
      notes: r.Notes || ''
    }))
  };
}

function saveInventoryData(payload) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) throw new Error('No active spreadsheet');
  ensureInventorySheets_(ss);
  const defs = inventorySheetDefs_();

  const writeRows = (def, rows) => {
    const sh = ss.getSheetByName(def.name);
    if (!sh) return;
    const values = (rows || []).map(row => def.fields.map(f => {
      const v = row?.[f];
      if (typeof v === 'boolean') return v ? 'TRUE' : 'FALSE';
      return v ?? '';
    }));
    sh.clearContents();
    sh.getRange(1, 1, 1, def.headers.length).setValues([def.headers]);
    if (values.length) {
      sh.getRange(2, 1, values.length, def.headers.length).setValues(values);
    }
    sh.setFrozenRows(1);
  };

  writeRows(defs.constitution, payload?.constitution);
  writeRows(defs.parts, payload?.parts);
  writeRows(defs.built, payload?.built);
  writeRows(defs.liquidation, payload?.liquidation);
  writeRows(defs.clients, payload?.clients);
  writeRows(defs.approvals, payload?.approvals);
  writeRows(defs.refill, payload?.refill);

  return { ok: true, msg: 'Inventory saved.' };
}
